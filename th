src/0.c:		if (memcmp(vrl_header->vrl_sig,"VRL1",4) || memcmp(vrl_header->fmt_sig,"VGAX",4)) return 1;
src/0.c:		if (vrl_header->width == 0 || vrl_header->height == 0) return 1;
src/0.c:	vrl_lineoffs = vrl1_vgax_genlineoffsets(vrl_header,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/0.c:			o = (i >> 2) + (0x10000UL - (uint16_t)gvar.video.page[1].data);
src/0.c:		x = -(gvar.video.page[0].dx);
src/0.c:		y = -(gvar.video.page[0].dy);
src/0.c:				if (x >= overdraw) rx = (x - overdraw) & (~3);
src/0.c:				else rx = -(gvar.video.page[0].dx);
src/0.c:				if (y >= overdraw) ry = (y - overdraw);
src/0.c:				else ry = -(gvar.video.page[0].dy);
src/0.c:				h = vrl_header->height + overdraw + y - ry;
src/0.c:				w = (x + vrl_header->width + (overdraw*2) + 3/*round up*/ - rx) & (~3);
src/0.c:				if ((rx+w) > gvar.video.page[0].width) w = gvar.video.page[0].width-rx;
src/0.c:				if ((ry+h) > gvar.video.page[0].height) h = gvar.video.page[0].height-ry;
src/0.c:				o = (0x10000UL - (uint16_t)gvar.video.page[1].data) + (ry * gvar.video.page[0].stridew) + (rx >> 2); // source offscreen
src/0.c:				vga_state.vga_draw_stride_limit = (gvar.video.page[0].width + 3/*round up*/ - x) >> 2;
src/0.c:draw_vrl1_vgax_modex(x-rx,y-ry,vrl_header,vrl_lineoffs,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/0.c:				if ((x + vrl_header->width) >= ((gvar.video.page[0].width + gvar.video.page[0].dx) - 1) || x == -(gvar.video.page[0].dx))
src/0.c:					xdir = -xdir;
src/0.c:				if ((y + vrl_header->height) >= ((gvar.video.page[0].height + gvar.video.page[0].dy) - 1) || y == -(gvar.video.page[0].dy))
src/0.c:					ydir = -ydir;
src/0.c:			dstart = (gvar.video.page[0].height - dh) / 2; // center the squash effect on screen, otherwise it would squash to top of screen
src/0.c:			if (dstart >= dh_blankfill) y = dstart - dh_blankfill;
src/0.c:			dh -= dh_step;
src/16.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/16.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/16.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/16.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/bakapi4b.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669
src/bakapi4b.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/bakapi.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/bakapi.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/bakapi.c:		if (*a == '-') {
src/bakapi.c:			do { a++; } while (*a == '-');
src/bakapi.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/bakapi.c:	//      the CPU to carry out tasks. --J.C.
src/bakapi.c:	VGAmodeX(vgamodex_mode, 1, &gvar); // TODO: Suggestion: Instead of magic numbers for the first param, might I suggest defining an enum or some #define constants that are easier to remember? --J.C.
src/bakapi.c:		// we'll integrate DOSLIB vga into that part of the code instead for less disruption. -- J.C.
src/bakapi.c:						gvar.video.page[0].dx--;
src/bakapi.c:						gvar.video.page[0].dy--;
src/bakapi.c:		// we'll integrate DOSLIB vga into that part of the code instead for less disruption. -- J.C.
src/bakapi.c:					key = c - '0';
src/bakapi.c:		// we'll integrate DOSLIB vga into that part of the code instead for less disruption. -- J.C.
src/bakapi.c:// INFO: This is a testing section for textrendering and panning for project 16 --sparky4
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-48, "========================================");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-40, "|    |Chikyuu:$line1");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-32, "|    |$line2");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-24, "|    |$line3");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-16, "|    |$line4");
src/bakapi.c:// 		mxOutText(xpos+1, ypos+gvar.video.page[0].height-8,  "========================================");
src/bakapi.c:// 	if( (xpos>(gvar.video.page[0].sw-gvar.video.page[0].width-1))  || (xpos<1)){xdir=-xdir;}
src/bakapi.c:// 	if( (ypos>(gvar.video.page[0].sh-gvar.video.page[0].height-1)) || (ypos<1)){ydir=-ydir;}
src/bakapi.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/bakapi.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/bakapi.h://project 16 testing define switch for veiwing the contents of the video memory --sparky4
src/bakapi.h:#define BOINK // what does this mean? --J.C.
src/emmtest.c:		len--;
src/emmtest.c:	pEmmData = (byte *)EMMalloc(&hEData, EMMCoreLeft());  // get 6 * 16K bytes - 96K
src/emmtest.c:	MapEMM(hEData, 0, PEMMDATAPAGENUM);   // load 1st 4 pages into page frame: 0-3
src/emmtest.c://----	UnmapEMM(hEData, 0, 4);          // not absolutely necessary
src/emmtest.c:	MapEMM(hEData, 4, 2);            // map last 2 pages: 4-5
src/emsdump.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/emsdump.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/emstest.c:          if (avail == -1)
src/exmmtest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/exmmtest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/exmmtest.c:#pragma warn -pro
src/exmmtest.c:#pragma warn -use
src/fmemtest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/fmemtest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/fontgfx.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/fontgfx.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/fontgfx.c:                                        `::--.:'.::'\n\
src/fontgfx.c:                                          |. _:===-'\n\
src/fontgfx.c:                        ,---.---.    __,','\n\
src/fontgfx.c:                       (~`.  \   )   )','.,---..\n\
src/fontgfx.c:                        `v`\ | ,' .-'.:,'_____   `.\n\
src/fontgfx.c:                            )|/.-~.--~~--.   ~~~-. \ \n\
src/fontgfx.c:                          _/-'_.-~        ""---.._`.|\n\
src/fontgfx.c:                     _.-~~_.-~                    ""'\n\
src/fontgfx.c:              _..--~~_.(~~\n\
src/fontgfx.c:   __...---~~~_..--~~\n\
src/fontgfx.c:,'___...---~~~\n\
src/fontgfx.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/fontgfx.c:	//      the CPU to carry out tasks. --J.C.
src/fontgfx.c:	// NTS: We're in Mode-X now. printf() is useless. Do not use printf(). Or INT 10h text printing. Or DOS console output.
src/fontgfx.c:	modexprint(&gvar.video.page[0], gvar.video.page[0].width - (8*16)/*HACK: The rose ASCII is too wide for 320x240 so offset it to make sure the petals are visible*/, 8, 1, 45, 0, &rose);
src/fonttest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/fonttest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/inputest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/inputest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/maptest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/maptest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/maptest.c:	if(map.width*map.height != 1200) exit(-3);
src/midi.c: * (C) 2010-2012 Jonathan Campbell.
src/midi.c: *   - MS-DOS [pure DOS mode, or Windows or OS/2 DOS Box]
src/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence) {
src/midi.c:		t->eof = 1;
src/midi.c:	c = *(t->read);
src/midi.c:	if (FP_OFF(t->read) >= 0xF) /* 16:16 far pointer aware (NTS: Programs reassigning this pointer MUST normalize the FAR pointer) */
src/midi.c:		t->read = MK_FP(FP_SEG(t->read)+0x1,0);
src/midi.c:		t->read++;
src/midi.c:	t->read++;
src/midi.c:	t->wait = ~0UL;
src/midi.c:	t->read = t->fence;
src/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence)
src/midi.c:		tt = farptr2phys(t->read);
src/midi.c:		rem = farptr2phys(t->fence) - tt;
src/midi.c:		t->read = MK_FP(tt>>4,tt&0xF);
src/midi.c:	rem = (unsigned long)(t->fence - t->read);
src/midi.c:	t->read += len;
src/midi.c:	unsigned int tch = (unsigned int)(t - midi_trk); /* pointer math */
src/midi.c:	unsigned int ach = (unsigned int)(ch - midi_ch); /* pointer math */
src/midi.c:	unsigned int ach = (unsigned int)(ch - midi_ch); /* pointer math */
src/midi.c:	note->busy = 1;
src/midi.c:	note->note_number = key;
src/midi.c:	note->note_velocity = vel;
src/midi.c:	note->note_track = (unsigned int)(t - midi_trk);
src/midi.c:	note->note_channel = (unsigned int)(ch - midi_ch);
src/midi.c:	ach = (unsigned int)(note - midi_notes); /* which FM channel? */
src/midi.c:	adlib_fm[ach].mod.attack_rate = vel >> 3; /* 0-127 to 0-15 */
src/midi.c:	if ((ch->program >= 8 && ch->program <= 15)/*Chromatic percussion*/ ||
src/midi.c:		(ch->program >= 112 && ch->program <= 119)/*Percussive*/ ||
src/midi.c:		ch == &midi_ch[9]/*MIDI channel 10 (DAMN YOU 1-BASED COUNTING)*/)
src/midi.c:	note->busy = 1;
src/midi.c:	note->note_number = key;
src/midi.c:	note->note_velocity = vel;
src/midi.c:	note->note_track = (unsigned int)(t - midi_trk);
src/midi.c:	note->note_channel = (unsigned int)(ch - midi_ch);
src/midi.c:	ach = (unsigned int)(note - midi_notes); /* which FM channel? */
src/midi.c:	adlib_fm[ach].mod.attack_rate = vel >> 3; /* 0-127 to 0-15 */
src/midi.c:	note->busy = 0;
src/midi.c:	ach = (unsigned int)(note - midi_notes); /* which FM channel? */
src/midi.c:	adlib_fm[ach].mod.attack_rate = vel >> 3; /* 0-127 to 0-15 */
src/midi.c:	ch->program = inst;
src/midi.c:static inline void on_pitch_bend(struct midi_track *t,struct midi_channel *ch,int bend/*-8192 to 8192*/) {
src/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence)
src/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence) {
src/midi.c:		t->eof = 1;
src/midi.c:	t->us_tick_cnt_mtpq += 10000UL * (unsigned long)ticks_per_quarter_note;
src/midi.c:	while (t->us_tick_cnt_mtpq >= t->us_per_quarter_note) {
src/midi.c:		t->us_tick_cnt_mtpq -= t->us_per_quarter_note;
src/midi.c:		while (t->wait == 0) {
src/midi.c:			if ((unsigned long)t->read >= (unsigned long)t->fence) {
src/midi.c:				t->eof = 1;
src/midi.c:						t->last_status = 0;
src/midi.c:						t->last_status = b;
src/midi.c:				b = t->last_status;
src/midi.c:					on_pitch_bend(t,ch,((c&0x7F)|((d&0x7F)<<7))-8192); /* c=LSB d=MSB */
src/midi.c://							fprintf(stderr,"Type 0x7F len=%lu %p/%p/%p\n",len,t->raw,t->read,t->fence);
src/midi.c:								d -= 3;
src/midi.c:								t->us_per_quarter_note = ((unsigned long)midi_trk_read(t)<<16UL)+
src/midi.c:											t->us_per_quarter_note;
src/midi.c://								fprintf(stderr,"Type 0x%02x len=%lu %p/%p/%p\n",c,d,t->raw,t->read,t->fence);
src/midi.c:							fprintf(stderr,"t=%u Unknown MIDI f message 0x%02x 0x%02x %p/%p/%p\n",i,b,c,t->raw,t->read,t->fence);
src/midi.c://						fprintf(stderr,"Sysex len=%lu %p/%p/%p\n",len,t->raw,t->read,t->fence);
src/midi.c:						fprintf(stderr,"t=%u Unknown MIDI message 0x%02x at %p/%p/%p\n",i,b,t->raw,t->read,t->fence);
src/midi.c:			t->wait = midi_trk_read_delta(t);
src/midi.c:		if (t->wait != 0) {
src/midi.c:			t->wait--;
src/midi.c:/* WARNING: subroutine call in interrupt handler. make sure you compile with -zu flag for large/compact memory models */
src/midi.c:		irq0_cnt -= irq0_max;
src/midi.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/midi.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/midi.c:		f->mod_multiple = 1;
src/midi.c:		f->total_level = 63 - 16;
src/midi.c:		f->attack_rate = 15;
src/midi.c:		f->decay_rate = 4;
src/midi.c:		f->sustain_level = 0;
src/midi.c:		f->release_rate = 8;
src/midi.c:		f->f_number = 400;
src/midi.c:		f->sustain = 1;
src/midi.c:		f->octave = 4;
src/midi.c:		f->key_on = 0;
src/midi.c:		f->mod_multiple = 1;
src/midi.c:		f->total_level = 63 - 16;
src/midi.c:		f->attack_rate = 15;
src/midi.c:		f->decay_rate = 4;
src/midi.c:		f->sustain_level = 0;
src/midi.c:		f->release_rate = 8;
src/midi.c:		f->f_number = 0;
src/midi.c:		f->sustain = 1;
src/midi.c:		f->octave = 0;
src/midi.c:		f->key_on = 0;
src/midi.c:	t->eof = 0;
src/midi.c:	t->last_status = 0;
src/midi.c:	t->us_tick_cnt_mtpq = 0;
src/midi.c:	t->us_per_quarter_note = (60000000UL / 120UL); /* 120BPM */
src/midi.c:	t->read = midi_trk[i].raw;
src/midi.c:	t->wait = midi_trk_read_delta(t); /* and then the read pointer will point at the MIDI event when wait counts down */
src/midi.c:			/* byte 0-1 = format type (0,1 or 2) */
src/midi.c:			/* byte 2-3 = number of tracks */
src/midi.c:			/* byte 4-5 = time divison */
src/midi.c:					cando = 0x10000UL - (unsigned long)FP_OFF(p);
src/midi.c:					if (cando > 0xFFFFUL) cando = 0xFFFFUL; /* we're limited to 64KB-1 of reading */
src/midi.c:					rem -= cando;
src/midi.c:		adv = irq0_ticks - ptick;
src/midi.c:			adv--;
src/miditest.c: * (C) 2010-2012 Jonathan Campbell.
src/miditest.c: *   - MS-DOS [pure DOS mode, or Windows or OS/2 DOS Box]
src/miditest.c:		adv = irq0_ticks - ptick;
src/miditest.c:			adv--;
src/palettec.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/palettec.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/palettel.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/palettel.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/pcxtest2.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/pcxtest2.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/pcxtest2.c://----#include "src/lib/planar.h"
src/pcxtest2.c:	for(px = plane; px < p->width; px+=4) {
src/pcxtest2.c:		for(py=0; py<p->height/2; py++) {
src/pcxtest2.c:		if(!sprite || p->plane[offset])
src/pcxtest2.c:			page->data = p->plane;
src/pcxtest2.c:		//offset+=p->width;
src/pcxtest2.c://----	planar_buf_t *p;
src/pcxtest2.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/pcxtest2.c:	//      the CPU to carry out tasks. --J.C.
src/pcxtest2.c://----	p = planar_buf_from_bitmap(&bmp);
src/pcxtest2.c:	t1 = (*clockw-start) /18.2;
src/pcxtest2.c:	t2 = (*clockw-start)/18.2;
src/pcxtest2.c:	//_fmemset(MK_FP(0xA000, 0), (int)p->plane, gvar.video.page[0].sw*(gvar.video.page[0].sh*2));
src/pcxtest2.c:	printf("\n%d\n", sizeof(p->plane));
src/pcxtest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/pcxtest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/pcxtest.c://----	planar_buf_t *p;
src/pcxtest.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/pcxtest.c:	//      the CPU to carry out tasks. --J.C.
src/pcxtest.c://----	p = planar_buf_from_bitmap(&bmp);
src/pcxtest.c:	t1 = (*clockw-start) /18.2;
src/pcxtest.c:	t2 = (*clockw-start)/18.2;
src/pcxtest.c:	//_fmemset(MK_FP(0xA000, 0), (int)p->plane, gvar.video.page[0].sw*(gvar.video.page[0].sh*2));
src/pcxtest.c:	printf("\n%d\n", sizeof(p->plane));
src/planrpcx.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/planrpcx.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/planrpcx.c:	t1 = (*clockw-start) /18.2;
src/planrpcx.c:		modexDrawBmpPBufRegion	(&gvar.video.page[0], p.width+32, 32, p.width-(p.width/4), p.height-(p.height/4), p.width/4, p.height/4, &p);
src/planrpcx.c:	t2 = (*clockw-start) /18.2;
src/planrpcx.c:// 	t2 = (*clockw-start)/18.2;
src/planrpcx.c:	t3 = (*clockw-start) /18.2;
src/planrpcx.c:		modexDrawPBufRegion	(&gvar.video.page[0], p.width, 0, p.width-(p.width/4), p.height-(p.height/4), p.width/4, p.height/4, &p, 0);//(&gvar.video.page[0], 0, 0, 0+p.width, 0, p.width, p.height, &p, 0);
src/planrpcx.c:	t4 = (*clockw-start) /18.2;
src/planrpcx.c:	fprintf(stderr,"%dx%d\n", gvar.video.page[0].sw-(p.width), gvar.video.page[0].sh-(p.height));
src/scroll.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/scroll.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/scroll.c:	//mappalptr = map.tiles->btdata->palette;
src/scroll.c://	printf("Total used @ before palette initiation:		%zu\n", oldfreemem-GetFreeSize());
src/scroll.c:		modexPalUpdate1(player[0].data->palette);
src/scroll.c://++++0000		modexPalUpdate1(map.tiles->btdata->palette);
src/scroll.c:	//printf("	%d\n", sizeof(ptmp->data));
src/scroll.c://++++	map.tiles->data->offset=(paloffset/3);
src/scroll.c:	//XTmodexPalUpdate(map.tiles->data, &paloffset, 0, 0);
src/scroll.c:	//_fmemcpy(mv[1].page->data, mv[0].page->data, mv[0].page->pagesize);
src/scroll.c:	modexClearRegion(mv[0].page, player[0].x, player[0].y-TILEWH, 16, 32, 15);
src/scroll.c:	//modexClearRegion(mv[1].page, player[0].x, player[0].y-TILEWH, 16, 32, 15);
src/scroll.c:	//PBUFSFUN(mv[1].page, player[0].x, player[0].y-TILEWH, 16, 64, 24, 32,	PLAYERBMPDATA);
src/scroll.c:	PBUFSFUN(mv[0].page, player[0].x, player[0].y-TILEWH, 16, 64, 16, 32,	player[0].data);
src/scroll.c:// 	modexClearRegion(mv[2].page, 0, 0, mv[2].page->width, mv[2].page->height, 47);
src/scroll.c:// 	modexClearRegion(mv[3].page, 0, 0, mv[3].page->width, mv[3].page->height, 45);
src/scroll.c:	if(((mv[0].map->data[(player[0].triggerx-1)+(map.width*(player[0].triggery-1))] == 0) && IN_KeyDown(0x1C))||(player[0].tx == 5 && player[0].ty == 5))
src/scroll.c:		for(i=800; i>=400; i--)
src/scroll.c:	if(player[0].q == (TILEWH/(player[0].speed))+1 && player[0].info.dir != 2 && (player[0].triggerx == 5 && player[0].triggery == 5)){ player[0].hp--; }
src/scroll.c:	 modexPalUpdate(map.tiles->data, &paloffset, 0, 0);
src/scroll.c:		modexClearRegion(mv[1].page, 0, 0, mv[1].page->width, mv[1].page->height, 2);
src/scroll.c:		modexClearRegion(mv[2].page, 0, 0, mv[2].page->width, mv[2].page->height, 3);
src/scroll.c:		modexClearRegion(mv[3].page, 0, 0, mv[3].page->width, mv[3].page->height, 4);
src/scroll.c:		_fmemset(((mv[pg].page->data+4)+(16*(mv[pg].page->width/4))), 15, 4);
src/sountest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/sountest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/sountest.c:		exit(-5);
src/sountest.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/sountest.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/sountest.c:		f->mod_multiple = 1;
src/sountest.c:		f->total_level = 63 - 16;
src/sountest.c:		f->attack_rate = 15;
src/sountest.c:		f->decay_rate = 0;
src/sountest.c:		f->sustain_level = 7;
src/sountest.c:		f->release_rate = 7;
src/sountest.c:		f->f_number = musical_scale[i%18];
src/sountest.c:		f->octave = 4;
src/sountest.c:		f->key_on = 0;
src/sountest.c:		f->mod_multiple = 1;
src/sountest.c:		f->total_level = 63 - 16;
src/sountest.c:		f->attack_rate = 15;
src/sountest.c:		f->decay_rate = 0;
src/sountest.c:		f->sustain_level = 7;
src/sountest.c:		f->release_rate = 7;
src/sountest.c:		f->f_number = 0;
src/sountest.c:		f->octave = 0;
src/sountest.c:		f->key_on = 0;
src/test2.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/test2.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/test2.c://----    planar_buf_t *p;
src/test2.c:		for(y=0; y < p->height; y++) {
src/test2.c:			for(x=0; x < p->pwidth; x++) {
src/test2.c:				printf("%02X ", (int) p->plane[plane][i++]);
src/test2.c:    //fwrite(p, 1, p->width*p->height, file);
src/test.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/test.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/test.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/test.c:	//      the CPU to carry out tasks. --J.C.
src/test.c:	_DEBUG("Serial debug output started\n"); // NTS: All serial output must end messages with newline, or DOSBox-X will not emit text to log
src/test.c:	modexClearRegion(&gvar.video.page[1], 32, 32, gvar.video.page[1].sw-32, gvar.video.page[1].sh-32, 42);
src/test.c:	modexClearRegion(&gvar.video.page[1], 48, 48, gvar.video.page[1].sw-64, gvar.video.page[1].sh-64, 128);
src/test.c:	modexClearRegion(&gvar.video.page[0], 32, 32, gvar.video.page[0].sw-32, gvar.video.page[0].sh-32, 42);
src/test.c:	modexClearRegion(&gvar.video.page[0], 48, 48, gvar.video.page[0].sw-64, gvar.video.page[0].sh-64, 128);
src/test.c:	modexClearRegion(&gvar.video.page[0], 32, 32, gvar.video.page[0].sw-32, gvar.video.page[0].sh-32, 42);
src/test.c:	modexClearRegion(&gvar.video.page[0], 48, 48, gvar.video.page[0].sw-64, gvar.video.page[0].sh-64, 128);
src/test.c:				gvar.video.page[pan.pn].dx--;
src/test.c:				gvar.video.page[pan.pn].dy--;
src/test.c:			modexClearRegion(&gvar.video.page[1], 0, gvar.video.page[0].height/2, gvar.video.page[0].width-32, 16, 45);*/
src/test.c:// 				modexClearRegion(&gvar.video.page[1], 32, 32, gvar.video.page[1].sw-32, gvar.video.page[1].sh-32, 42);
src/test.c:// 				modexClearRegion(&gvar.video.page[1], 48, 48, gvar.video.page[1].sw-64, gvar.video.page[1].sh-64, 128);
src/test.c:		if(IN_KeyDown(12)) modexClearRegion(&gvar.video.page[0], (gvar.video.page[0].width/2)-4, (gvar.video.page[0].height/2)-16, 24, 32, 15);
src/test.c:		if(IN_KeyDown(13)) modexClearRegion(&gvar.video.page[1], (gvar.video.page[1].width/2)-4, (gvar.video.page[1].height/2)-16, 24, 32, 15);
src/testemm0.c: * (C) 2011-2012 Jonathan Campbell.
src/testemm0.c:	fprintf(stderr,"memcpy %p -> %p (%lu)\n",
src/testemm0.c:	    c--;
src/testemm0.c:				printf("  %02x: 0x%04x",me->number,me->segment);
src/testemm0.c:					if (!emm_map_page(h1,1,0)) printf("cannot map log 1 -> phys 0\n");
src/testemm0.c:					if (!emm_map_page(h1,0,1)) printf("cannot map log 0 -> phys 1\n");
src/testemm.c: * (C) 2011-2012 Jonathan Campbell.
src/testemm.c:	fprintf(stderr,"memcpy %p -> %p (%lu)\n",
src/testemm.c:	    c--;
src/testemm.c:				printf("  %02x: 0x%04x",me->number,me->segment);
src/testemm.c:					if (!emm_map_page(h1,1,0)) printf("cannot map log 1 -> phys 0\n");
src/testemm.c:					if (!emm_map_page(h1,0,1)) printf("cannot map log 0 -> phys 1\n");
src/testsnd.c: * (C) 2010-2012 Jonathan Campbell.
src/testsnd.c: *   - MS-DOS [pure DOS mode, or Windows or OS/2 DOS Box]
src/testsnd.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/testsnd.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/testsnd.c:		f->mod_multiple = 1;
src/testsnd.c:		f->total_level = 63 - 16;
src/testsnd.c:		f->attack_rate = 15;
src/testsnd.c:		f->decay_rate = 0;
src/testsnd.c:		f->sustain_level = 7;
src/testsnd.c:		f->release_rate = 7;
src/testsnd.c:		f->f_number = musical_scale[i%18];
src/testsnd.c:		f->octave = 4;
src/testsnd.c:		f->key_on = 0;
src/testsnd.c:		f->mod_multiple = 1;
src/testsnd.c:		f->total_level = 63 - 16;
src/testsnd.c:		f->attack_rate = 15;
src/testsnd.c:		f->decay_rate = 0;
src/testsnd.c:		f->sustain_level = 7;
src/testsnd.c:		f->release_rate = 7;
src/testsnd.c:		f->f_number = 0;
src/testsnd.c:		f->octave = 0;
src/testsnd.c:		f->key_on = 0;
src/testsnd.c:				sprintf(tmp,"Adlib FM, %u-voice %s. Use Z & X to adj  F10=PRESET F1=QUIET ",adlib_fm_voices,
src/testsnd.c:					"F-Number",
src/testsnd.c:					"Connection (operator 1 -> operator 2)",
src/testsnd.c:					bd->am_depth,
src/testsnd.c:					bd->vibrato_depth,
src/testsnd.c:					bd->rythm_enable,
src/testsnd.c:					bd->bass_drum_on,
src/testsnd.c:					bd->snare_drum_on,
src/testsnd.c:					bd->tom_tom_on,
src/testsnd.c:					bd->cymbal_on,
src/testsnd.c:					bd->hi_hat_on);
src/testsnd.c:					cc = sprintf(tmp,"%u  %u  %u    %u   %-2u   %u   %-2u %-2u %-2u %-2u %-2u %u   %u   %-4u %u    %u   %u  %c%c%c%c %u %.1fHz ",
src/testsnd.c:						f->am,			f->vibrato,		f->sustain,		f->key_scaling_rate,
src/testsnd.c:						f->mod_multiple,	f->level_key_scale,	f->total_level,		f->attack_rate,
src/testsnd.c:						f->decay_rate,		f->sustain_level,	f->release_rate,	f->key_on,
src/testsnd.c:						f->octave,		f->f_number,		f->feedback,		f->connection,
src/testsnd.c:						f->waveform,		f->ch_a?'*':'-',	f->ch_b?'*':'-',	f->ch_c?'*':'-',
src/testsnd.c:						f->ch_d?'*':'-',	i+1,			freq);
src/testsnd.c:					cc = sprintf(tmp,"%u  %u  %u    %u   %-2u   %u   %-2u %-2u %-2u %-2u %-2u                       %u       CAR   ",
src/testsnd.c:						f->am,			f->vibrato,		f->sustain,		f->key_scaling_rate,
src/testsnd.c:						f->mod_multiple,	f->level_key_scale,	f->total_level,		f->attack_rate,
src/testsnd.c:						f->decay_rate,		f->sustain_level,	f->release_rate,	f->waveform);
src/testsnd.c:					struct adlib_fm_operator *f = &adlib_fm[selector].mod; f->ch_a ^= 1;
src/testsnd.c:					struct adlib_fm_operator *f = &adlib_fm[selector].mod; f->ch_b ^= 1;
src/testsnd.c:					struct adlib_fm_operator *f = &adlib_fm[selector].mod; f->ch_c ^= 1;
src/testsnd.c:					struct adlib_fm_operator *f = &adlib_fm[selector].mod; f->ch_d ^= 1;
src/testsnd.c:					case 0:		f->am ^= 1;			adlib_update_group20(operator,f); break;
src/testsnd.c:					case 11:	f->key_on ^= 1;			adlib_update_groupA0(selector,&adlib_fm[selector]); break;
src/testsnd.c:					case 1:		f->vibrato ^= 1;		adlib_update_group20(operator,f); break;
src/testsnd.c:					case 2:		f->sustain ^= 1;		adlib_update_group20(operator,f); break;
src/testsnd.c:					case 15:	f->connection ^= 1;		adlib_update_group20(operator,f); break;
src/testsnd.c:					case 3:		f->key_scaling_rate ^= 1;	adlib_update_group20(operator,f); break;
src/testsnd.c:					case 4:		if (dec) f->mod_multiple--; else f->mod_multiple++;
src/testsnd.c:					case 5:		if (dec) f->level_key_scale--; else f->level_key_scale++;
src/testsnd.c:					case 6:		if (dec) f->total_level--; else f->total_level++;
src/testsnd.c:					case 7:		if (dec) f->attack_rate--; else f->attack_rate++;
src/testsnd.c:					case 8:		if (dec) f->decay_rate--; else f->decay_rate++;
src/testsnd.c:					case 9:		if (dec) f->sustain_level--; else f->sustain_level++;
src/testsnd.c:					case 10:	if (dec) f->release_rate--; else f->release_rate++;
src/testsnd.c:					case 12:	if (dec) f->octave--; else f->octave++;
src/testsnd.c:					case 13:	if (dec) f->f_number--; else f->f_number++;
src/testsnd.c:					case 14:	if (dec) f->feedback--; else f->feedback++;
src/testsnd.c:					case 16:	if (dec) f->waveform--; else f->waveform++;
src/testsnd.c:					selector--;
src/testsnd.c:					hselect--;
src/tesuto.c:		if (memcmp(vrl_header->vrl_sig,"VRL1",4) || memcmp(vrl_header->fmt_sig,"VGAX",4)) return 1;
src/tesuto.c:		if (vrl_header->width == 0 || vrl_header->height == 0) return 1;
src/tesuto.c:	vrl_lineoffs = vrl1_vgax_genlineoffsets(vrl_header,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/tesuto.c:			if (x >= overdraw) rx = (x - overdraw) & (~3);
src/tesuto.c:			if (y >= overdraw) ry = (y - overdraw);
src/tesuto.c:			h = vrl_header->height + overdraw + y - ry;
src/tesuto.c:			w = (x + vrl_header->width + (overdraw*2) + 3/*round up*/ - rx) & (~3);
src/tesuto.c:			if ((rx+w) > vga_state.vga_width) w = vga_state.vga_width-rx;
src/tesuto.c:			if ((ry+h) > vga_state.vga_height) h = vga_state.vga_height-ry;
src/tesuto.c:			vga_state.vga_draw_stride_limit = (vga_state.vga_width + 3/*round up*/ - x) >> 2;
src/tesuto.c:				o = (i-rx) >> 2;
src/tesuto.c:			draw_vrl1_vgax_modex(x-rx,y-ry,vrl_header,vrl_lineoffs,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/tesuto.c:			if (x >= (vga_state.vga_width - 1) || x == 0)
src/tesuto.c:				xdir = -xdir;
src/tesuto.c:			if (y >= (vga_state.vga_height - 1) || y == 0)
src/tesuto.c:				ydir = -ydir;
src/tesuto.c:		const unsigned int pattern_ofs = 0x10000UL - (vga_state.vga_stride * vga_state.vga_height);
src/tesuto.c:			if (x >= overdraw) rx = (x - overdraw) & (~3);
src/tesuto.c:			if (y >= overdraw) ry = (y - overdraw);
src/tesuto.c:			h = vrl_header->height + overdraw + y - ry;
src/tesuto.c:			w = (x + vrl_header->width + (overdraw*2) + 3/*round up*/ - rx) & (~3);
src/tesuto.c:			if ((rx+w) > vga_state.vga_width) w = vga_state.vga_width-rx;
src/tesuto.c:			if ((ry+h) > vga_state.vga_height) h = vga_state.vga_height-ry;
src/tesuto.c:			vga_state.vga_draw_stride_limit = (vga_state.vga_width + 3/*round up*/ - x) >> 2;
src/tesuto.c:			draw_vrl1_vgax_modex(x-rx,y-ry,vrl_header,vrl_lineoffs,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/tesuto.c:			if (x >= (vga_state.vga_width - 1) || x == 0)
src/tesuto.c:				xdir = -xdir;
src/tesuto.c:			if (y >= (vga_state.vga_height - 1) || y == 0)
src/tesuto.c:				ydir = -ydir;
src/tesuto.c:			dstart = (vga_state.vga_height - dh) / 2; // center the squash effect on screen, otherwise it would squash to top of screen
src/tesuto.c:			if (dstart >= dh_blankfill) y = dstart - dh_blankfill;
src/tesuto.c:			dh -= dh_step;
src/tesuto.h:#define OW	GVPO.width-16
src/tesuto.h:#define OH	GVPO.height-16
src/tesuto.h:#define IW	GVPI.width-16
src/tesuto.h:#define IH	GVPI.height-16
src/tesuto.h:	modexClearRegion(&gvar.video.page[1], 32, 32, gvar.video.page[1].sw-32, gvar.video.page[1].sh-32, 42); \
src/tesuto.h:	modexClearRegion(&gvar.video.page[1], 48, 48, gvar.video.page[1].sw-64, gvar.video.page[1].sh-64, 128); \
src/tesuto.h:	modexClearRegion(&gvar.video.page[0], 32, 32, gvar.video.page[0].sw-32, gvar.video.page[0].sh-32, 42); \
src/tesuto.h:	modexClearRegion(&gvar.video.page[0], 48, 48, gvar.video.page[0].sw-64, gvar.video.page[0].sh-64, 128); \
src/tesuto.h://unsigned char vga_stride = 80; // 80 x 4 = 320 for 320-pixel wide modes
src/tsthimem.c: * (C) 2010-2012 Jonathan Campbell.
src/tsthimem.c:			printf("  - HMA is present\n");
src/tsthimem.c:			printf("  - Extensions are present to address up to 4GB of memory\n");
src/tsthimem.c:		if (h1 != -1) printf("ok, handle %u\n",h1);
src/tsthimem.c:		if (h2 != -1) printf("ok, handle %u\n",h2);
src/tsthimem.c:		if (h3 != -1) printf("ok, handle %u\n",h3);
src/tsthimem.c:		if (h1 != -1) {
src/tsthimem.c:			if (!himem_sys_free(h1)) printf(" - Free failed\n");
src/tsthimem.c:		if (h2 != -1) {
src/tsthimem.c:			if (!himem_sys_free(h2)) printf(" - Free failed\n");
src/tsthimem.c:		if (h3 != -1) {
src/tsthimem.c:			if (!himem_sys_free(h3)) printf(" - Free failed\n");
src/tsthimem.c:		if (h3 != -1) {
src/tsthimem.c:				printf(" - Locked: Physical memory address 0x%08lX\n",(unsigned long)ofs);
src/tsthimem.c:				if (!himem_sys_unlock(h3)) printf(" - Cannot unlock\n");
src/tsthimem.c:				printf(" - Cannot lock\n");
src/tsthimem.c:					printf(" - Locked: Physical memory address 0x%08lX\n",(unsigned long)ofs);
src/tsthimem.c:					if (!himem_sys_unlock(h3)) printf(" - Cannot unlock\n");
src/tsthimem.c:					printf(" - Cannot lock\n");
src/tsthimem.c:				printf(" - Cannot realloc\n");
src/tsthimem.c:			if (!himem_sys_free(h3)) printf(" - Free failed\n");
src/tsthimem.c:		if (h3 != -1) {
src/tsthimem.c:				printf(" - Locked: Physical memory address 0x%08lX\n",(unsigned long)ofs);
src/tsthimem.c:				if (!himem_sys_unlock(h3)) printf(" - Cannot unlock\n");
src/tsthimem.c:				printf(" - Cannot lock\n");
src/tsthimem.c:					printf(" - Locked: Physical memory address 0x%08lX\n",(unsigned long)ofs);
src/tsthimem.c:					if (!himem_sys_unlock(h3)) printf(" - Cannot unlock\n");
src/tsthimem.c:					printf(" - Cannot lock\n");
src/tsthimem.c:				printf(" - Cannot realloc\n");
src/tsthimem.c:			if (!himem_sys_free(h3)) printf(" - Free failed\n");
src/vgacamm.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/vgacamm.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/vgacamm.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/vgacamm.c:	//      the CPU to carry out tasks. --J.C.
src/vgacamm.c:	t1 = (*clockw-start) /18.2;
src/vgacamm.c:	t2 = (*clockw-start)/18.2;
src/vgmtest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/vgmtest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/vrstest.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/vrstest.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/vrstest.c:	vrs.data_size = size - sizeof(struct vrl1_vgax_header);
src/vrstest.c:	vrl_id_iter = (uint16_t far *)(vrs.buffer + vrs.vrs_hdr->offset_table[VRS_HEADER_OFFSET_SPRITE_ID_LIST]);
src/vrstest.c:	vrl_headers_offsets = (uint32_t far *)(vrs.buffer + vrs.vrs_hdr->offset_table[VRS_HEADER_OFFSET_VRS_LIST]);
src/vrstest.c:		// Calc. vrl size as (next_offset - curr_offset)
src/vrstest.c:		if (i != num_of_vrl - 1){
src/vrstest.c:			vrl_size = vrl_headers_offsets[i+1] - vrl_headers_offsets[i] - sizeof(struct vrl1_vgax_header);
src/vrstest.c:		// If it's the last vrl, size is (next_vrs_struct_offset - curr_offset)
src/vrstest.c:			vrl_size = vrs.vrs_hdr->offset_table[VRS_HEADER_OFFSET_SPRITE_ID_LIST] - vrl_headers_offsets[i] - sizeof(struct vrl1_vgax_header);
src/vrstest.c:	if (i == -1)
src/vrstest.c:	t1 = (*clockw-start) /18.2;
src/vrstest.c:	t2 = (*clockw-start)/18.2;
src/vrstest.c:	//MM_FreePtr(&((void __based(sega)*)spri.spritesheet->buffer), &mm);
src/zcroll.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/zcroll.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/zcroll.c:	//IN CA i think you use CAL_SetupGrFile but i do think we should work together on this part --sparky4
src/zcroll.c:	player[0].ent->spri = malloc(sizeof(struct sprite));
src/zcroll.c:	player[0].ent->spri->spritesheet = malloc(sizeof(struct vrs_container));
src/zcroll.c:	read_vrs(&gvar, "data/spri/chikyuu.vrs", player[0].ent->spri->spritesheet);
src/zcroll.c:	player[0].ent->spri->x = player[0].ent->spri->y = TILEWH;
src/zcroll.c:	i = set_anim_by_id(player[0].ent->spri, 11);
src/zcroll.c:	print_anim_ids(player[0].ent->spri);
src/zcroll.c:	if (i == -1)
src/zcroll.c:	animate_spri((player[0].ent->spri), &gvar);
src/zcroll.c:/*		if(((mv[0].map->data[(player[0].triggerx-1)+(map.width*(player[0].triggery-1))] == 0) && IN_KeyDown(0x1C))||(player[0].tx == 5 && player[0].ty == 5))
src/zcroll.c:			for(i=800; i>=400; i--)
src/zcroll.c:		if(player[0].q == (TILEWH/(player[0].speed))+1 && player[0].info.dir != 2 && (player[0].triggerx == 5 && player[0].triggery == 5)){ player[0].hp--; }
src/zcroll.c:			modexClearRegion(mv[0].page, 0, 0, mv[0].page->width, mv[0].page->height, 2);
src/zcroll.c:					player[0].ent->spri->x = 0;
src/zcroll.c:					player[0].ent->spri->delay = 1; animate_spri((player[0].ent->spri), &gvar); player[0].ent->spri->x += 20;
src/zcroll.c:			_fmemset(((mv[pg].page->data+4)+(16*(mv[pg].page->width/4))), 15, 4);
src/lib/16_ca.c: * Copyright (C) 1993-2014 Flat Rock Software
src/lib/16_ca.c: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_ca.c:---------------------------
src/lib/16_ca.c:#pragma warn -pro
src/lib/16_ca.c:#pragma warn -use
src/lib/16_ca.c://https://github.com/open-watcom/open-watcom-v2/issues/279#issuecomment-244587566 for _seg
src/lib/16_ca.c:  word bit0,bit1;	// 0-255 is a character, > is a pointer to a node
src/lib/16_ca.c:long		_seg *grstarts;	// array of offsets in egagraph, -1 for sparse
src/lib/16_ca.c:		value = -1;
src/lib/16_ca.c:	gvar->handle.debughandle = open("debug.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.debughandle = open("debug.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	close(gvar->handle.debughandle);
src/lib/16_ca.c:	chunkcomplen = GRFILEPOS(chunk+1)-GRFILEPOS(chunk)-4;
src/lib/16_ca.c:	if(gvar->pm.emm.EMSVer<0x40)
src/lib/16_ca.c:		//segm=(length%0xfffflu)-1;
src/lib/16_ca.c:		//length-=fat;
src/lib/16_ca.c:	if(gvar->pm.emm.EMSVer<0x40)
src/lib/16_ca.c:		//segm=(length%0xfffflu)-1;
src/lib/16_ca.c:		//length-=fat;
src/lib/16_ca.c:	if((handle = open(filename,O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:	if (handle == -1)
src/lib/16_ca.c:	if((handle = open(filename,O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:= Goes through a huffman table and changes the 256-511 node numbers to the
src/lib/16_ca.c:	if (node->bit0 >= 256)
src/lib/16_ca.c:	  node->bit0 = (unsigned)(table+(node->bit0-256));
src/lib/16_ca.c:	if (node->bit1 >= 256)
src/lib/16_ca.c:	  node->bit1 = (unsigned)(table+(node->bit1-256));
src/lib/16_ca.c:  source--;
src/lib/16_ca.c:  dest--;
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c://--------------------------
src/lib/16_ca.c:  length--;
src/lib/16_ca.c:				length--;
src/lib/16_ca.c:				copyptr = outptr - offset;
src/lib/16_ca.c:				length -= count;
src/lib/16_ca.c:				while (count--)
src/lib/16_ca.c:				length --;
src/lib/16_ca.c:				length -= count;
src/lib/16_ca.c:				while (count--)
src/lib/16_ca.c:			length --;
src/lib/16_ca.c:  complength = 2*(dest-start);
src/lib/16_ca.c:		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:	if (grhandle == -1)
src/lib/16_ca.c:// 		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:	if ((gvar->ca.file.maphandle[0] = open("data/test.map",
src/lib/16_ca.c:		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:// 		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:// 		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:		 O_RDONLY | O_BINARY, S_IREAD)) == -1)
src/lib/16_ca.c:	gvar->handle.profilehandle = open("profile.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.profilehandle = open("profile.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.showmemhandle = open("meminfo.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.showmemhandle = open("meminfo.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->ca.camap.mapon = -1;
src/lib/16_ca.c:	gvar->ca.ca_levelbit = 1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum = 0;
src/lib/16_ca.c:	close(gvar->handle.profilehandle);
src/lib/16_ca.c: 	close(gvar->handle.showmemhandle);
src/lib/16_ca.c:	close(*(gvar->ca.file.maphandle));
src/lib/16_ca.c:// MDM begin - (GAMERS EDGE)
src/lib/16_ca.c:	compressed = audiostarts[chunk+1]-pos;
src/lib/16_ca.c:	spr = &spritetable[chunk-STARTSPRITES];
src/lib/16_ca.c:	smallplane = spr->width*spr->height;
src/lib/16_ca.c:	dest->sourceoffset[0] = MAXSHIFTS*6;	// start data after 3 unsigned tables
src/lib/16_ca.c:	dest->planesize[0] = smallplane;
src/lib/16_ca.c:	dest->width[0] = spr->width;
src/lib/16_ca.c:	CAL_HuffExpand (compressed, &dest->data[0],smallplane*2,grhuffman);
src/lib/16_ca.c:	spr = &spritetable[chunk-STARTSPRITES];
src/lib/16_ca.c:	smallplane = spr->width*spr->height;
src/lib/16_ca.c:	bigplane = (spr->width+1)*spr->height;
src/lib/16_ca.c:	expanded = shiftstarts[spr->shifts];
src/lib/16_ca.c:	CAL_HuffExpand (compressed, &dest->data[0],smallplane*5,grhuffman);
src/lib/16_ca.c:	switch (spr->shifts)
src/lib/16_ca.c:			dest->sourceoffset[i] = shiftstarts[0];
src/lib/16_ca.c:			dest->planesize[i] = smallplane;
src/lib/16_ca.c:			dest->width[i] = spr->width;
src/lib/16_ca.c:			dest->sourceoffset[i] = shiftstarts[0];
src/lib/16_ca.c:			dest->planesize[i] = smallplane;
src/lib/16_ca.c:			dest->width[i] = spr->width;
src/lib/16_ca.c:			dest->sourceoffset[i] = shiftstarts[1];
src/lib/16_ca.c:			dest->planesize[i] = bigplane;
src/lib/16_ca.c:			dest->width[i] = spr->width+1;
src/lib/16_ca.c:		CAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],
src/lib/16_ca.c:			dest->sourceoffset[2],spr->width,spr->height,4,true);
src/lib/16_ca.c:		dest->sourceoffset[0] = shiftstarts[0];
src/lib/16_ca.c:		dest->planesize[0] = smallplane;
src/lib/16_ca.c:		dest->width[0] = spr->width;
src/lib/16_ca.c:		dest->sourceoffset[1] = shiftstarts[1];
src/lib/16_ca.c:		dest->planesize[1] = bigplane;
src/lib/16_ca.c:		dest->width[1] = spr->width+1;
src/lib/16_ca.c:		CAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],
src/lib/16_ca.c:			dest->sourceoffset[1],spr->width,spr->height,2,true);
src/lib/16_ca.c:		dest->sourceoffset[2] = shiftstarts[2];
src/lib/16_ca.c:		dest->planesize[2] = bigplane;
src/lib/16_ca.c:		dest->width[2] = spr->width+1;
src/lib/16_ca.c:		CAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],
src/lib/16_ca.c:			dest->sourceoffset[2],spr->width,spr->height,4,true);
src/lib/16_ca.c:		dest->sourceoffset[3] = shiftstarts[3];
src/lib/16_ca.c:		dest->planesize[3] = bigplane;
src/lib/16_ca.c:		dest->width[3] = spr->width+1;
src/lib/16_ca.c:		CAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],
src/lib/16_ca.c:			dest->sourceoffset[3],spr->width,spr->height,6,true);
src/lib/16_ca.c:	while (GRFILEPOS(next) == -1)		// skip past any sparse tiles
src/lib/16_ca.c:	compressed = GRFILEPOS(next)-pos;
src/lib/16_ca.c:	gvar->video.grneeded[chunk] |= ca_levelbit;		// make sure it doesn't get removed
src/lib/16_ca.c:// MDM begin - (GAMERS EDGE)
src/lib/16_ca.c:	while (GRFILEPOS(next) == -1)		// skip past any sparse tiles
src/lib/16_ca.c:	compressed = GRFILEPOS(next)-pos;
src/lib/16_ca.c:	if (gvar->ca.map.mapon>-1 && gvar->ca.map.mapheaderseg[gvar->ca.map.mapon])
src/lib/16_ca.c:		MM_SetPurge (&((memptr)gvar->ca.map.mapheaderseg[(gvar->ca.map.mapon)]), 3, &(gvar->mm));
src/lib/16_ca.c:		if (gvar->ca.map.mapsegs[plane])
src/lib/16_ca.c:			MM_FreePtr (&(memptr)gvar->ca.map.mapsegs[plane], &(gvar->mm));
src/lib/16_ca.c:	gvar->ca.map.mapon = gvar->ca.map.mapnum;
src/lib/16_ca.c:	if (!gvar->ca.map.mapheaderseg[gvar->ca.map.mapnum])
src/lib/16_ca.c:		//pos = ((mapfiletype	_seg *)tinf)->headeroffsets[mapnum];
src/lib/16_ca.c:		pos = ((_seg *)gvar->ca.map.tinf)->headeroffsets[gvar->ca.map.mapnum];
src/lib/16_ca.c:		MM_GetPtr(&(memptr)gvar->ca.mapheaderseg[mapnum],sizeof(maptype));
src/lib/16_ca.c:		MM_SetPurge (&(memptr)mapheaderseg[mapnum], 0, &(gvar->mm));
src/lib/16_ca.c:	size = mapheaderseg[mapnum]->width * mapheaderseg[mapnum]->height * 2;
src/lib/16_ca.c:		pos = mapheaderseg[mapnum]->planestart[plane];
src/lib/16_ca.c:		compressed = mapheaderseg[mapnum]->planelength[plane];
src/lib/16_ca.c:		((mapfiletype _seg *)tinf)->RLEWtag);
src/lib/16_ca.c:		((mapfiletype _seg *)tinf)->RLEWtag);
src/lib/16_ca.c:	if (gvar->ca.ca_levelnum==7)
src/lib/16_ca.c:	gvar->ca.ca_levelbit<<=1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum++;
src/lib/16_ca.c:	if (!gvar->ca.ca_levelnum)
src/lib/16_ca.c:	gvar->ca.ca_levelbit>>=1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum--;
src/lib/16_ca.c:		gvar->video.grneeded[i]&=~gvar->ca.ca_levelbit;
src/lib/16_ca.c:	_fmemset (gvar->video.grneeded,0,sizeof(gvar->video.grneeded));
src/lib/16_ca.c:	gvar->ca.ca_levelbit = 1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum = 0;
src/lib/16_ca.c:// draw dialog window (masked tiles 12 - 20 are window borders)
src/lib/16_ca.c:	if (xh - lastx > BARSTEP)
src/lib/16_ca.c:		if (gvar->video.grneeded[i]&ca_levelbit)
src/lib/16_ca.c:// MDM begin - (GAMERS EDGE)
src/lib/16_ca.c:		if ( (gvar->video.grneeded[i]&ca_levelbit) && !grsegs[i])
src/lib/16_ca.c:			while (GRFILEPOS(next) == -1)		// skip past any sparse tiles
src/lib/16_ca.c:			compressed = GRFILEPOS(next)-pos;
src/lib/16_ca.c:					source = (byte _seg *)bufferseg+(pos-bufferstart);
src/lib/16_ca.c:						!(gvar->video.grneeded[next]&ca_levelbit && !grsegs[next]))
src/lib/16_ca.c:						while (GRFILEPOS(++next) == -1)	// skip past any sparse tiles
src/lib/16_ca.c:						if (nextpos - endpos <= MAXEMPTYREAD
src/lib/16_ca.c:						&& nextendpos-pos <= BUFFERSIZE)
src/lib/16_ca.c:					CA_FarRead(grhandle,bufferseg,endpos-pos);
src/lib/16_ca.h: * Copyright (C) 1993-2014 Flat Rock Software
src/lib/16_ca.h: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_dbg.c:		// in DOSBox-X, the "log" mode will receive our text and print it into the log file
src/lib/16_dbg.h:	return -1;
src/lib/16_hc.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_hc.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_hc.c:		s0 ^= s0 & -s0;
src/lib/16_hc.c:		s0 ^= s0 & -s0;
src/lib/16_hc.c:		s0 ^= s0 & -s0;
src/lib/16_hc.c:		s0 ^= s0 & -s0;
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:		write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:		write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:		write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:	strcat(scratch,"----------------  --------   --------   --------\n");
src/lib/16_hc.c:	strcat(scratch,"----------------  --------   --------   --------\n");
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:			strcpy((str),"OK - end of heap\n");
src/lib/16_hc.c:			strcpy((str),"OK - heap is empty\n");
src/lib/16_hc.c:			strcpy((str),"ERROR - heap is damaged\n");
src/lib/16_hc.c:			strcpy((str),"ERROR - bad pointer to heap\n");
src/lib/16_hc.c:			strcpy((str),"ERROR - bad node in heap\n");
src/lib/16_hc.c:	write(gvar->handle.heaphandle,(str),strlen((str)));
src/lib/16_hc.c:			//printf("OK - end of heap\n");
src/lib/16_hc.c:			//printf("OK - heap is empty\n");
src/lib/16_hc.c:			printf("ERROR - heap is damaged\n");
src/lib/16_hc.c:			printf("ERROR - bad pointer to heap\n");
src/lib/16_hc.c:			printf("ERROR - bad node in heap\n");
src/lib/16_hc.c:	gvar->handle.heaphandle = open("heap.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_hc.c:	gvar->handle.heaphandle = open("heap.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_hc.c:	close(gvar->handle.heaphandle);
src/lib/16_hc.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_hc.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_head.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_head.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_head.c://      US_CheckParm() - checks to see if a string matches one of a set of
src/lib/16_head.c://              index of the string that matched, or -1 if no matches were found
src/lib/16_head.c:	while (!isalpha(*parm)) // Skip non-alphas
src/lib/16_head.c:	return(-1);
src/lib/16_head.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_head.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_head.h:#define KEY_DASH		(0x0C)	// -_
src/lib/16_head.h:#define _FCORELEFT 0x90000UL-16UL
src/lib/16_in.c: * Copyright (C) 1993-2014 Flat Rock Software
src/lib/16_in.c: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_in.c://	ID_IN.c - Input Manager
src/lib/16_in.c://		LastScan - The keyboard scan code of the last key pressed
src/lib/16_in.c://		LastASCII - The ASCII value of the last key pressed
src/lib/16_in.c://	DEBUG - there are more globals
src/lib/16_in.c:	0  ,27 ,'1','2','3','4','5','6','7','8','9','0','-','=',8  ,9  ,	// 0
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',	// 4
src/lib/16_in.c:	0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',	// 4
src/lib/16_in.c:	"?","?","1","2","3","4","5","6","7","8","9","0","-","+","?","?",
src/lib/16_in.c:	"?","?","?","?","?","?","?","?","\xf","?","-","\x15","5","\x11","+","?",
src/lib/16_in.c:					},	// DEBUG - consolidate these
src/lib/16_in.c://	INL_KeyService() - Handles a keyboard interrupt (key up/down)
src/lib/16_in.c:// DEBUG - handle special keys: ctl-alt-delete, print scrn
src/lib/16_in.c:					// DEBUG - make caps lock light work
src/lib/16_in.c:						c += 'a' - 'A';
src/lib/16_in.c:						c -= 'a' - 'A';
src/lib/16_in.c://	INL_GetMouseDelta() - Gets the amount that the mouse has moved from the
src/lib/16_in.c://	INL_GetMouseButtons() - Gets the status of the mouse buttons from the
src/lib/16_in.c://	IN_GetJoyAbs() - Reads the absolute position of the specified joystick
src/lib/16_in.c:		jz		done		// We have a silly value - abort
src/lib/16_in.c://	INL_GetJoyDelta() - Returns the relative movement of the specified
src/lib/16_in.c://		joystick (from +/-127, scaled adaptively)
src/lib/16_in.c:	if (x < def->threshMinX)
src/lib/16_in.c:		if (x < def->joyMinX)
src/lib/16_in.c:			x = def->joyMinX;
src/lib/16_in.c:		x = -(x - def->threshMinX);
src/lib/16_in.c:		x *= def->joyMultXL;
src/lib/16_in.c:		*dx = (x > 127)? -127 : -x;
src/lib/16_in.c:	else if (x > def->threshMaxX)
src/lib/16_in.c:		if (x > def->joyMaxX)
src/lib/16_in.c:			x = def->joyMaxX;
src/lib/16_in.c:		x = x - def->threshMaxX;
src/lib/16_in.c:		x *= def->joyMultXH;
src/lib/16_in.c:	if (y < def->threshMinY)
src/lib/16_in.c:		if (y < def->joyMinY)
src/lib/16_in.c:			y = def->joyMinY;
src/lib/16_in.c:		y = -(y - def->threshMinY);
src/lib/16_in.c:		y *= def->joyMultYL;
src/lib/16_in.c:		*dy = (y > 127)? -127 : -y;
src/lib/16_in.c:	else if (y > def->threshMaxY)
src/lib/16_in.c:		if (y > def->joyMaxY)
src/lib/16_in.c:			y = def->joyMaxY;
src/lib/16_in.c:		y = y - def->threshMaxY;
src/lib/16_in.c:		y *= def->joyMultYH;
src/lib/16_in.c:		time = (TimeCount - lasttime) / 2;
src/lib/16_in.c://	INL_GetJoyButtons() - Returns the button status of the specified
src/lib/16_in.c:	result >>= joy? 6 : 4;	// Shift into bits 0-1
src/lib/16_in.c://	IN_GetJoyButtonsDB() - Returns the de-bounced button status of the
src/lib/16_in.c://	INL_StartKbd() - Sets up my keyboard stuff for use
src/lib/16_in.c://	INL_ShutKbd() - Restores keyboard control to the BIOS
src/lib/16_in.c://	INL_StartMouse() - Detects and sets up the mouse
src/lib/16_in.c://	INL_ShutMouse() - Cleans up after the mouse
src/lib/16_in.c://	INL_SetJoyScale() - Sets up scaling values for the specified joystick
src/lib/16_in.c:	def->joyMultXL = JoyScaleMax / (def->threshMinX - def->joyMinX);
src/lib/16_in.c:	def->joyMultXH = JoyScaleMax / (def->joyMaxX - def->threshMaxX);
src/lib/16_in.c:	def->joyMultYL = JoyScaleMax / (def->threshMinY - def->joyMinY);
src/lib/16_in.c:	def->joyMultYH = JoyScaleMax / (def->joyMaxY - def->threshMaxY);
src/lib/16_in.c://	IN_SetupJoy() - Sets up thresholding values and calls INL_SetJoyScale()
src/lib/16_in.c:	def->joyMinX = minx;
src/lib/16_in.c:	def->joyMaxX = maxx;
src/lib/16_in.c:	r = maxx - minx;
src/lib/16_in.c:	def->threshMinX = ((r / 2) - d) + minx;
src/lib/16_in.c:	def->threshMaxX = ((r / 2) + d) + minx;
src/lib/16_in.c:	def->joyMinY = miny;
src/lib/16_in.c:	def->joyMaxY = maxy;
src/lib/16_in.c:	r = maxy - miny;
src/lib/16_in.c:	def->threshMinY = ((r / 2) - d) + miny;
src/lib/16_in.c:	def->threshMaxY = ((r / 2) + d) + miny;
src/lib/16_in.c://	INL_StartJoy() - Detects & auto-configures the specified joystick
src/lib/16_in.c://					The auto-config assumes the joystick is centered
src/lib/16_in.c:		((x == 0) || (x > MaxJoyValue - 10))
src/lib/16_in.c:	||	((y == 0) || (y > MaxJoyValue - 10))
src/lib/16_in.c://	INL_ShutJoy() - Cleans up the joystick stuff
src/lib/16_in.c://	IN_Startup() - Starts up the Input Mgr
src/lib/16_in.c://	IN_Default() - Sets up default conditions for the Input Mgr
src/lib/16_in.c://	IN_Shutdown() - Shuts down the Input Mgr
src/lib/16_in.c://	IN_SetKeyHook() - Sets the routine that gets called by INL_KeyService()
src/lib/16_in.c://	IN_ClearKeyDown() - Clears the keyboard array
src/lib/16_in.c://	INL_AdjustCursor() - Internal routine of common code from IN_ReadCursor()
src/lib/16_in.c:		info->button0 = true;
src/lib/16_in.c:		info->button1 = true;
src/lib/16_in.c:	info->x += dx;
src/lib/16_in.c:	info->y += dy;
src/lib/16_in.c://	IN_ReadCursor() - Reads the input devices and fills in the cursor info
src/lib/16_in.c:	info->x = info->y = 0;
src/lib/16_in.c:	info->button0 = info->button1 = false;
src/lib/16_in.c://	IN_ReadControl() - Reads the device associated with the specified
src/lib/16_in.c:		my = (dbyte & 3) - 1;
src/lib/16_in.c:		mx = ((dbyte >> 2) & 3) - 1;
src/lib/16_in.c:		if (!(--DemoBuffer[DemoOffset]))
src/lib/16_in.c:			def = &(inpu.KbdDefs[type - ctrl_Keyboard]);
src/lib/16_in.c:/*			if (Keyboard[def->upleft])
src/lib/16_in.c:			else if (Keyboard[def->upright])
src/lib/16_in.c:			else if (Keyboard[def->downleft])
src/lib/16_in.c:			else if (Keyboard[def->downright])
src/lib/16_in.c:			if(!inpu.Keyboard[def->left] && !inpu.Keyboard[def->right]){
src/lib/16_in.c:				if((inpu.Keyboard[def->up] && !inpu.Keyboard[def->down]))
src/lib/16_in.c:				if((inpu.Keyboard[def->down] && !inpu.Keyboard[def->up]))
src/lib/16_in.c:			}else if(!inpu.Keyboard[def->up] && !inpu.Keyboard[def->down]){
src/lib/16_in.c:				if((inpu.Keyboard[def->left] && !inpu.Keyboard[def->right]))
src/lib/16_in.c:				if((inpu.Keyboard[def->right] && !inpu.Keyboard[def->left]))
src/lib/16_in.c:							if((inpu.Keyboard[def->left] && !inpu.Keyboard[def->right])){ dir = DirTable[1]; }//mx = motion_Left; }
src/lib/16_in.c:							else if((inpu.Keyboard[def->right] && !inpu.Keyboard[def->left])){ dir = DirTable[3]; }//mx = motion_Right; }
src/lib/16_in.c:							if((inpu.Keyboard[def->up] && !inpu.Keyboard[def->down])){ dir = DirTable[0]; }//my = motion_Up; }
src/lib/16_in.c:							else if((inpu.Keyboard[def->down] && !inpu.Keyboard[def->up])){ dir = DirTable[4]; }//my = motion_Down; }
src/lib/16_in.c:			if (inpu.Keyboard[def->button0])
src/lib/16_in.c:			if (inpu.Keyboard[def->button1])
src/lib/16_in.c:			INL_GetJoyDelta(type - ctrl_Joystick,&dx,&dy,false);
src/lib/16_in.c:			buttons = INL_GetJoyButtons(type - ctrl_Joystick);
src/lib/16_in.c:	conpee=(((my + 1) * 2) + (mx + 1))-1;
src/lib/16_in.c:if(player[pn].info.dir!=2/*(inpu.Keyboard[def->up] || inpu.Keyboard[def->down] || inpu.Keyboard[def->left] || inpu.Keyboard[def->right])*/ || player[pn].q>1)
src/lib/16_in.c:	//else if(!realdelta) printf("%c%d %c%d %c%d %c%d", dirchar(0), inpu.Keyboard[def->up], dirchar(4), inpu.Keyboard[def->down], dirchar(1), inpu.Keyboard[def->left], dirchar(3), inpu.Keyboard[def->right]);
src/lib/16_in.c://	IN_SetControlType() - Sets the control type to be used by the specified
src/lib/16_in.c:	// DEBUG - check that requested type is present?
src/lib/16_in.c://	IN_StartDemoRecord() - Starts the demo recording, using a buffer the
src/lib/16_in.c://	IN_StartDemoPlayback() - Plays back the demo pointed to of the given size
src/lib/16_in.c://	IN_StopDemo() - Turns off demo mode
src/lib/16_in.c://	IN_FreeDemoBuffer() - Frees the demo buffer, if it's been allocated
src/lib/16_in.c://	IN_GetScanName() - Returns a string containing the name of the
src/lib/16_in.c://	IN_WaitForKey() - Waits for a scan code, then clears LastScan and
src/lib/16_in.c://	IN_WaitForASCII() - Waits for an ASCII char, then clears LastASCII and
src/lib/16_in.c://	IN_AckBack() - Waits for either an ASCII keypress or a button press
src/lib/16_in.c://	IN_Ack() - Clears user input & then calls IN_AckBack()
src/lib/16_in.c://	IN_IsUserInput() - Returns true if a key has been pressed or a button
src/lib/16_in.c://	IN_UserInput() - Waits for the specified delay time (in ticks) or the
src/lib/16_in.c:	} while (TimeCount - lasttime < delay);
src/lib/16_in.h: * Copyright (C) 1993-2014 Flat Rock Software
src/lib/16_in.h: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_in.h://	ID_IN.h - Header file for Input Manager
src/lib/16_in.h:						//ctrl_None,				// MDM (GAMERS EDGE) - added
src/lib/16_in.h:						motion_Left = -1,motion_Up = -1,
src/lib/16_in.h:////0000----
src/lib/16_map.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_map.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_map.c:	if (tok->type == JSMN_STRING && (int) strlen(s) == tok->end - tok->start &&
src/lib/16_map.c:			strncmp(json + tok->start, s, tok->end - tok->start) == 0) {
src/lib/16_map.c:	return -1;
src/lib/16_map.c:	fprintf(stdout, "t->size=[%d]	", t->size);
src/lib/16_map.c://0000fprintf(stderr, "t->type=%d\n", t->type);
src/lib/16_map.c:	if (t->type == JSMN_PRIMITIVE) {
src/lib/16_map.c:				so we can initiate the map which allocates the facking map->tiles->data->data properly and THEN we can return
src/lib/16_map.c:			map->data[q] = (byte)atoi(js+t->start);
src/lib/16_map.c:				fprintf(stdout, "%d[%d]", q, map->data[q]);
src/lib/16_map.c:			map->height = atoi(js+t->start);
src/lib/16_map.c:			fprintf(stdout, "h:[%d]\n", map->height);
src/lib/16_map.c:			map->width = atoi(js+t->start);
src/lib/16_map.c:			fprintf(stdout, "w:[%d]\n", map->width);
src/lib/16_map.c:	} else if (t->type == JSMN_STRING) {
src/lib/16_map.c://			fprintf(stdout, "[[[[%d|%d]]]]\n", &(t+1)->size, (t+1)->size);
src/lib/16_map.c://			fprintf(stdout, "\n%.*s[xx[%d|%d]xx]\n", (t+1)->end - (t+1)->start, js+(t+1)->start, &(t+1)->size, (t+1)->size);
src/lib/16_map.c:			map->data = malloc(sizeof(byte) * (t+1)->size);
src/lib/16_map.c:			map->tiles = malloc(sizeof(tiles_t));
src/lib/16_map.c:			map->tiles->btdata = malloc(sizeof(bitmap_t));
src/lib/16_map.c:			map->tiles->btdata = &bp;
src/lib/16_map.c://----			map->tiles->data = planar_buf_from_bitmap(&bp);
src/lib/16_map.c:			//map->tiles->data->data = malloc((16/**2*/)*16);
src/lib/16_map.c:			//map->tiles->data->width = (16/**2*/);
src/lib/16_map.c:			//map->tiles->data->height= 16;
src/lib/16_map.c:			map->tiles->tileHeight = 16;
src/lib/16_map.c:			map->tiles->tileWidth = 16;
src/lib/16_map.c:			map->tiles->rows = 1;
src/lib/16_map.c:			map->tiles->cols = 1;
src/lib/16_map.c:			strcpy(js_sv, "data");//strdup(js+t->start);//, t->end - t->start);
src/lib/16_map.c:			strcpy(js_sv, "height");//strdup(js+t->start);//, t->end - t->start);
src/lib/16_map.c:			strcpy(js_sv, "width");//strdup(js+t->start);//, t->end - t->start);
src/lib/16_map.c:	} else if (t->type == JSMN_OBJECT) {
src/lib/16_map.c:		for (i = 0; i < t->size; i++) {
src/lib/16_map.c:			j += dump(js, t+1+j, count-j, indent+1, js_sv, map, i);
src/lib/16_map.c:			j += dump(js, t+1+j, count-j, indent+1, js_sv, map, i);
src/lib/16_map.c:	} else if (t->type == JSMN_ARRAY) {
src/lib/16_map.c:		for (i = 0; i < t->size; i++) {
src/lib/16_map.c:			//for (k = 0; k < indent-1; k++) fprintf(stdout, "\t");
src/lib/16_map.c:			//fprintf(stdout, "\t-");
src/lib/16_map.c:			j += dump(js, t+1+j, count-j, indent+1, js_sv, map, i);
src/lib/16_map.c:			map->layerdata = malloc(sizeof(byte*) * t[i].size);
src/lib/16_map.c:					map->layerdata[k] = malloc(sizeof(byte) * t[i+1].size);
src/lib/16_map.c:						map->layerdata[k][j] = (byte)atoi(js + t[i+2+j].start);
src/lib/16_map.c:						printf("%d, ", map->layerdata[k][j]);
src/lib/16_map.c:			map->tiles = malloc(sizeof(tiles_t*) * t[i].size);
src/lib/16_map.c:					map->layertile[k] = malloc(sizeof(tiles_t));
src/lib/16_map.c:					map->layertile[k]->btdata = malloc(sizeof(bitmap_t));
src/lib/16_map.c:					map->layertile[k]->tileHeight = 16;
src/lib/16_map.c:					map->layertile[k]->tileWidth = 16;
src/lib/16_map.c:					map->layertile[k]->rows = 1;
src/lib/16_map.c:					map->layertile[k]->cols = 1;
src/lib/16_map.c:					map->layertile[k]->btdata = &bp;
src/lib/16_map.c:			map->height = atoi(js + t[i+1].start);
src/lib/16_map.c:			printf("Height: %d\n", map->height);
src/lib/16_map.c:			map->width = atoi(js + t[i+1].start);
src/lib/16_map.c:			printf("Width: %d\n", map->width);
src/lib/16_map.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_map.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_mm.c: * Copyright (C) 1993-2014 Flat Rock Software
src/lib/16_mm.c: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_mm.c:			--------------------------
src/lib/16_mm.c:---------
src/lib/16_mm.c:----------
src/lib/16_mm.c:#pragma warn -pro
src/lib/16_mm.c:#pragma warn -use
src/lib/16_mm.c:	gvar->mm.totalEMSpages=totalEMSpages;
src/lib/16_mm.c:	gvar->mm.freeEMSpages=freeEMSpages;
src/lib/16_mm.c:	gvar->mm.EMSPageFrame=EMSPageFrame;
src/lib/16_mm.c:	gvar->mm.EMSpagesmapped=EMSpagesmapped;
src/lib/16_mm.c:	gvar->mm.EMSHandle=EMSHandle;
src/lib/16_mm.c:	gvar->mm.EMSVer=EMSVer;
src/lib/16_mm.c:	unsigned EMSHandle=gvar->mm.EMSHandle;
src/lib/16_mm.c:	EMSHandle=gvar->mm.EMSHandle;
src/lib/16_mm.c:	gvar->mmi.EMSmem = (i)*0x4000lu;
src/lib/16_mm.c://  FOR x = 0 TO NumPages - 1
src/lib/16_mm.c:	EMSHandle=gvar->mm.EMSHandle;
src/lib/16_mm.c:	if(gvar->mm.EMSVer<0x40)
src/lib/16_mm.c:	gvar->mmi.EMSmem = (i)*0x4000lu;
src/lib/16_mm.c:	gvar->mmi.XMSmem += size*16;
src/lib/16_mm.c:	gvar->mm.UMBbase[gvar->mm.numUMBs] = base;
src/lib/16_mm.c:	gvar->mm.numUMBs++;
src/lib/16_mm.c:	if(gvar->mm.numUMBs < MAXUMBS)
src/lib/16_mm.c:	for (i=0;i<gvar->mm.numUMBs;i++)
src/lib/16_mm.c:		base = gvar->mm.UMBbase[i];
src/lib/16_mm.c:	scan = last = gvar->mm.mmhead;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// reset rover to start of memory
src/lib/16_mm.c:	while(scan->start+scan->length < segstart)
src/lib/16_mm.c:		scan = scan->next;
src/lib/16_mm.c:	oldend = scan->start + scan->length;
src/lib/16_mm.c:	extra = oldend - (segstart+seglength);
src/lib/16_mm.c:		scan->blob=segm;
src/lib/16_mm.c:	printf("len=%lu	", scan->length);
src/lib/16_mm.c:	if(segstart == scan->start)
src/lib/16_mm.c:		last->next = scan->next;			// unlink block
src/lib/16_mm.c:		scan->length = segstart-scan->start;	// shorten block
src/lib/16_mm.c:		gvar->mm.mmnew->useptr = NULL;
src/lib/16_mm.c:		gvar->mm.mmnew->next = scan->next;
src/lib/16_mm.c:		scan->next = gvar->mm.mmnew;
src/lib/16_mm.c:		gvar->mm.mmnew->start = segstart+seglength;
src/lib/16_mm.c:		gvar->mm.mmnew->length = extra;
src/lib/16_mm.c:		gvar->mm.mmnew->attributes = LOCKBIT;
src/lib/16_mm.c:	scan = last = gvar->mm.mmhead;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// reset rover to start of memory
src/lib/16_mm.c:	while (scan->start+scan->length < segstart)
src/lib/16_mm.c:		scan = scan->next;
src/lib/16_mm.c:	/*for(;seglength>=0x10000;seglength-=0xFFFF)
src/lib/16_mm.c:	oldend = scan->start + scan->length;
src/lib/16_mm.c:	extra = oldend - (segstart+((unsigned)seglength));
src/lib/16_mm.c:		printf("start=%x	", scan->start);
src/lib/16_mm.c:		printf("len=%lu	", scan->length);
src/lib/16_mm.c:	if (segstart == scan->start)
src/lib/16_mm.c:		last->next = scan->next;			// unlink block
src/lib/16_mm.c:		scan->length = segstart-scan->start;	// shorten block
src/lib/16_mm.c:		gvar->mm.mmnew->useptr = NULL;
src/lib/16_mm.c:		gvar->mm.mmnew->next = scan->next;
src/lib/16_mm.c:		scan->next = gvar->mm.mmnew;
src/lib/16_mm.c:		gvar->mm.mmnew->start = segstart+seglength;
src/lib/16_mm.c:		gvar->mm.mmnew->length = extra;
src/lib/16_mm.c:		gvar->mm.mmnew->attributes = LOCKBIT;
src/lib/16_mm.c:	scan = gvar->mm.mmhead->next;
src/lib/16_mm.c:		if(!(scan->attributes&LOCKBIT) && (scan->attributes&PURGEBITS))
src/lib/16_mm.c:			MM_FreePtr(scan->useptr, gvar);
src/lib/16_mm.c:		scan = scan->next;
src/lib/16_mm.c:	if(gvar->mm.mmstarted)
src/lib/16_mm.c:	gvar->mm.mmstarted = true;
src/lib/16_mm.c:	gvar->mm.bombonerror = true;
src/lib/16_mm.c:	gvar->mm.mmhead = NULL;
src/lib/16_mm.c:	gvar->mm.mmfree = &(gvar->mm.mmblocks[0]);
src/lib/16_mm.c:	for(i=0;i<MAXBLOCKS-1;i++)
src/lib/16_mm.c:		gvar->mm.mmblocks[i].next = &(gvar->mm.mmblocks[i+1]);
src/lib/16_mm.c:	gvar->mm.mmblocks[i].next = NULL;
src/lib/16_mm.c:	gvar->mm.mmhead = gvar->mm.mmnew;				// this will allways be the first node
src/lib/16_mm.c:	gvar->mm.mmnew->start = 0;
src/lib/16_mm.c:	gvar->mm.mmnew->length = 0xffff;
src/lib/16_mm.c:	gvar->mm.mmnew->attributes = LOCKBIT;
src/lib/16_mm.c:	gvar->mm.mmnew->next = NULL;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:	start = (void far *)(gvar->mm.nearheap = _nmalloc(length));
src/lib/16_mm.c:	start = (void far *)(gvar->mm.nearheap = malloc(length));
src/lib/16_mm.c:	length -= 16-(FP_OFF(start)&15);
src/lib/16_mm.c:	length -= SAVENEARHEAP;
src/lib/16_mm.c:	gvar->mmi.nearheap = length;
src/lib/16_mm.c:	printf("(farcoreleft()+32)-_FCORELEFT	%d\n", (sword)((farcoreleft()+32)-_FCORELEFT));
src/lib/16_mm.c:	start = gvar->mm.farheap = _fmalloc(length);
src/lib/16_mm.c:	//start = gvar->mm.farheap = halloc(length, 1);
src/lib/16_mm.c:	length -= 16-(FP_OFF(start)&15);
src/lib/16_mm.c:	length -= SAVEFARHEAP;
src/lib/16_mm.c:	gvar->mmi.farheap = length;
src/lib/16_mm.c:	gvar->mmi.mainmem = gvar->mmi.nearheap + gvar->mmi.farheap;
src/lib/16_mm.c:	gvar->mmi.EMSmem = 0;
src/lib/16_mm.c:		MML_UseSpace(gvar->mm.EMSPageFrame,(MAPPAGES)*0x4000lu, gvar);
src/lib/16_mm.c:		//if(gvar->pm.emm.EMSVer<0x40)
src/lib/16_mm.c:	gvar->mmi.XMSmem = 0;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// start looking for space after low block
src/lib/16_mm.c:	MM_GetPtr(&(gvar->mm.bufferseg),BUFFERSIZE, gvar);
src/lib/16_mm.c:	if(!(gvar->mm.mmstarted))
src/lib/16_mm.c:	_ffree(gvar->mm.farheap);//	printf("		far freed\n");
src/lib/16_mm.c:	_nfree(gvar->mm.nearheap);//	printf("		near freed\n");
src/lib/16_mm.c:	free(gvar->mm.nearheap);//	printf("		near freed\n");
src/lib/16_mm.c:	gvar->mm.mmnew->length = needed;
src/lib/16_mm.c:	gvar->mm.mmnew->useptr = baseptr;
src/lib/16_mm.c:	//if(gvar->mm.mmnew->useptr==NULL){
src/lib/16_mm.c:		printf("	baseptr=%Fp	", baseptr); printf("useptr=%Fp\n", gvar->mm.mmnew->useptr);
src/lib/16_mm.c:		printf("	*baseptr=%Fp	", *baseptr); printf("*useptr=%Fp\n", *(gvar->mm.mmnew->useptr));
src/lib/16_mm.c:		printf("	&baseptr=%Fp	", &baseptr); printf("&useptr=%Fp\n", &(gvar->mm.mmnew->useptr));
src/lib/16_mm.c:	//exit(-5); }
src/lib/16_mm.c:	gvar->mm.mmnew->attributes = BASEATTRIBUTES;
src/lib/16_mm.c:		if (search == 1 && gvar->mm.mmrover == gvar->mm.mmhead)
src/lib/16_mm.c:			lastscan = gvar->mm.mmrover;
src/lib/16_mm.c:			scan = gvar->mm.mmrover->next;
src/lib/16_mm.c:			lastscan = gvar->mm.mmhead;
src/lib/16_mm.c:			scan = gvar->mm.mmhead->next;
src/lib/16_mm.c:			endscan = gvar->mm.mmrover;
src/lib/16_mm.c:			lastscan = gvar->mm.mmhead;
src/lib/16_mm.c:			scan = gvar->mm.mmhead->next;
src/lib/16_mm.c:		startseg = lastscan->start + lastscan->length;
src/lib/16_mm.c:			if (scan->start - startseg >= needed)
src/lib/16_mm.c:				purge = lastscan->next;
src/lib/16_mm.c:				lastscan->next = gvar->mm.mmnew;
src/lib/16_mm.c:				gvar->mm.mmnew->start = *(unsigned *)baseptr = startseg;
src/lib/16_mm.c:				gvar->mm.mmnew->next = scan;
src/lib/16_mm.c:					next = purge->next;
src/lib/16_mm.c:				gvar->mm.mmrover = gvar->mm.mmnew;
src/lib/16_mm.c:			if ( (scan->attributes & LOCKBIT)
src/lib/16_mm.c:				|| !(scan->attributes & PURGEBITS) )
src/lib/16_mm.c:				startseg = lastscan->start + lastscan->length;
src/lib/16_mm.c:			scan=scan->next;		// look at next line
src/lib/16_mm.c:	if (gvar->mm.bombonerror)
src/lib/16_mm.c:		printf(OUT_OF_MEM_MSG,(size-gvar->mmi.nearheap));
src/lib/16_mm.c:		exit(-1);
src/lib/16_mm.c:		gvar->mm.mmerror = true;
src/lib/16_mm.c:	last = gvar->mm.mmhead;
src/lib/16_mm.c:	scan = last->next;
src/lib/16_mm.c:	if(baseptr == gvar->mm.mmrover->useptr)	// removed the last allocated block
src/lib/16_mm.c:		gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:	while(scan->useptr != baseptr && scan)
src/lib/16_mm.c:		scan = scan->next;
src/lib/16_mm.c:	last->next = scan->next;
src/lib/16_mm.c:	start = gvar->mm.mmrover;
src/lib/16_mm.c:		if(gvar->mm.mmrover->useptr == baseptr)
src/lib/16_mm.c:		gvar->mm.mmrover = gvar->mm.mmrover->next;
src/lib/16_mm.c:		if(!gvar->mm.mmrover)
src/lib/16_mm.c:			gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:		else if(gvar->mm.mmrover == start)
src/lib/16_mm.c:	gvar->mm.mmrover->attributes &= ~PURGEBITS;
src/lib/16_mm.c:	gvar->mm.mmrover->attributes |= purge;
src/lib/16_mm.c:	start = gvar->mm.mmrover;
src/lib/16_mm.c:		if(gvar->mm.mmrover->useptr == baseptr)
src/lib/16_mm.c:		gvar->mm.mmrover = gvar->mm.mmrover->next;
src/lib/16_mm.c:		if(!gvar->mm.mmrover)
src/lib/16_mm.c:			gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:		else if(gvar->mm.mmrover == start)
src/lib/16_mm.c:	gvar->mm.mmrover->attributes &= ~LOCKBIT;
src/lib/16_mm.c:	gvar->mm.mmrover->attributes |= locked*LOCKBIT;
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:		if(scan->attributes & LOCKBIT)
src/lib/16_mm.c:			start = scan->start + scan->length;
src/lib/16_mm.c:			if(scan->attributes & PURGEBITS)
src/lib/16_mm.c:				next = scan->next;
src/lib/16_mm.c:				last->next = next;
src/lib/16_mm.c:				if(scan->start != start)
src/lib/16_mm.c:					length = scan->length;
src/lib/16_mm.c:					source = scan->start;
src/lib/16_mm.c:						length -= 0xf00;
src/lib/16_mm.c:					scan->start = start;
src/lib/16_mm.c:					*(unsigned *)scan->useptr = start;
src/lib/16_mm.c:				start = scan->start + scan->length;
src/lib/16_mm.c:		scan = scan->next;		// go to next block
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:	end = -1;
src/lib/16_mm.c:		if(scan->attributes & PURGEBITS)
src/lib/16_mm.c:		if(scan->attributes & LOCKBIT)
src/lib/16_mm.c:		if(scan->start<=end)
src/lib/16_mm.c:			strcat(scratch, "\nscan->start's Size: ");
src/lib/16_mm.c:			ultoa (scan->start,str,10);
src/lib/16_mm.c:			write(gvar->handle.debughandle,scratch,strlen(scratch));
src/lib/16_mm.c:		end = scan->start+(scan->length)-1;
src/lib/16_mm.c://++++		chy = scan->start/320;
src/lib/16_mm.c://++++		chx = scan->start%320;
src/lib/16_mm.c:				//modexhlin(page, scan->start, (unsigned)end, chy, color);
src/lib/16_mm.c:				//for(chx=scan->start;chx+4>=(word)end;chx+=4)
src/lib/16_mm.c://++++		VW_Hlin(scan->start,(unsigned)end,0,color);
src/lib/16_mm.c:		for(w=(scan->start)/80;w<=end/80;w++)
src/lib/16_mm.c:			//printf("+	%u	%lu\n", w, scan->length);
src/lib/16_mm.c://++++		VW_Plot(scan->start,0,15);
src/lib/16_mm.c://++++			VW_Hlin(end+1,scan->next->start,0,0);	// black = free
src/lib/16_mm.c:		//wwww=(dword)(scan->next->start)-(dword)scan->start;
src/lib/16_mm.c:		//wwww=(dword)scan->start+(dword)(scan->next->start);
src/lib/16_mm.c:		if (scan->next && scan->next->start >= end+1)
src/lib/16_mm.c:			for(w=(end+1)/80;w<=((scan->next->start-scan->start)/80);w++)
src/lib/16_mm.c:				//printf("0	%x	%u	%lu\n", scan->next->start, w, scan->length);
src/lib/16_mm.c:			//printf("w=%u	wwww=%lu	start=%04x	next=%04x	end=%lu\n", w/80, wwww/80, scan->start, (scan->next->start), end+1);
src/lib/16_mm.c:		}/*else {//if(scan->next->start <= scan->start){
src/lib/16_mm.c:			scan->next->start=scan->start+0x1000;
src/lib/16_mm.c:			wwww=(dword)(scan->next->start)-(dword)scan->start;
src/lib/16_mm.c:				//printf("0	%x	%x	%u\n", scan->start, w);
src/lib/16_mm.c:			printf("w=%x	start=%x	next=%x	end=%u	%lu\n", w, scan->start, (scan->next->start), end+1, wwww);
src/lib/16_mm.c:			//for(chx=scan->next->start;chx+4>=(word)end+1;chx+=4)
src/lib/16_mm.c://				chx+=scan->next->start;
src/lib/16_mm.c:					//modexhlin(page, end+1,scan->next->start, chy, 0);
src/lib/16_mm.c:/*		y = scan->start/320;
src/lib/16_mm.c:		x = scan->start%320;
src/lib/16_mm.c://++++			VW_Hlin(x+end+1,x+(scan->next->start-scan->start),y,0);	// black = free
src/lib/16_mm.c:		ultoa (scan->start,str,16);
src/lib/16_mm.c:		ultoa ((unsigned)scan->length,str,10);
src/lib/16_mm.c:		owner = (unsigned)scan->useptr;
src/lib/16_mm.c:		write(gvar->handle.debughandle,scratch,strlen(scratch));
src/lib/16_mm.c:		write(gvar->handle.debughandle,scratch0,strlen(scratch0));
src/lib/16_mm.c:		scan = scan->next;
src/lib/16_mm.c:	ultoa (*(gvar->mm.nearheap),str,10);
src/lib/16_mm.c:	ultoa (*(gvar->mm.farheap),str,10);
src/lib/16_mm.c:	//strcat(scratch1, "&near=	%Fp ", &(gvar->mm.nearheap));
src/lib/16_mm.c:	//strcat(scratch1, "&far=	%Fp", &(gvar->mm.farheap));
src/lib/16_mm.c:	write(gvar->handle.debughandle,scratch1,strlen(scratch1));*/
src/lib/16_mm.c:	free(gvar->mm.nearheap);
src/lib/16_mm.c:	lowest = -1;
src/lib/16_mm.c:		scan = gvar->mm.mmhead;
src/lib/16_mm.c:			owner = (unsigned)scan->useptr;
src/lib/16_mm.c:			scan = scan->next;
src/lib/16_mm.c:			if (best->attributes & PURGEBITS)
src/lib/16_mm.c:				purge = '-';
src/lib/16_mm.c:			if (best->attributes & LOCKBIT)
src/lib/16_mm.c:				lock = '-';
src/lib/16_mm.c:			,(unsigned)lowest,lock,purge,best->length);
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:	while(scan->next)
src/lib/16_mm.c:		free += scan->next->start - (scan->start + scan->length);
src/lib/16_mm.c:		scan = scan->next;
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:	while(scan->next)
src/lib/16_mm.c:		if((scan->attributes&PURGEBITS) && !(scan->attributes&LOCKBIT))
src/lib/16_mm.c:			free += scan->length;
src/lib/16_mm.c:		free += scan->next->start - (scan->start + scan->length);
src/lib/16_mm.c:		scan = scan->next;
src/lib/16_mm.c:		printf("	%cLIMEMS	%u\n", 0xC9, gvar->pm.emm.EMSPresent);
src/lib/16_mm.c:		printf("	%c%cEMM v%x.%x available\n", 0xC7, 0xC4, gvar->pm.emm.EMSVer>>4,gvar->pm.emm.EMSVer&0x0F);
src/lib/16_mm.c:		printf("	%c%ctotalEMSpages:	%u	", 0xC7, 0xC4, gvar->pm.emm.totalEMSpages); printf("freeEMSpages:	%u\n", gvar->pm.emm.freeEMSpages);
src/lib/16_mm.c:		printf("	%c%cEMSPageFrame:	%04x\n", 0xC7, 0xC4, gvar->pm.emm.EMSPageFrame);
src/lib/16_mm.c:		printf("	%c%cEMSmem:	%lu\n", 0xD3, 0xC4, gvar->mmi.EMSmem);
src/lib/16_mm.c:		printf("	%cXMS	%u\n", 0xC9, gvar->pm.xmm.XMSPresent);
src/lib/16_mm.c:		printf("	%c%cXMSHandle:	%04x\n", 0xC7, 0xC4, gvar->pm.xmm.XMSHandle);
src/lib/16_mm.c:		printf("	%c%cXMSmem:	%lu\n", 0xD3, 0xC4, gvar->mmi.XMSmem);
src/lib/16_mm.c:	printf("	%cConv.	%u\n", 0xC9, gvar->pm.mm.MainPresent); DebugMemory_(gvar, 0);
src/lib/16_mm.c:	//printf("mainmem:	%lu\n", gvar->mmi.mainmem);
src/lib/16_mm.c:	//printf("Total convmem:	%lu	", gvar->mmi.mainmem); printf("TotalFree:	%lu	", MM_TotalFree(gvar)+gvar->mmi.EMSmem+gvar->mmi.XMSmem+gvar->mmi.XMSmem); printf("TotalUsed:	%lu\n", gvar->mmi.mainmem);
src/lib/16_mm.c:	printf("nearheap:	%lu		", gvar->mmi.nearheap); printf("farheap:	%lu\n", gvar->mmi.farheap);
src/lib/16_mm.c:			strcat(stri, "page-mapping hardware state save area is full");
src/lib/16_mm.c:	gvar->mm.bombonerror = bomb;
src/lib/16_mm.c:	if(!gvar->mm.mmfree)
src/lib/16_mm.c:	gvar->mm.mmnew=gvar->mm.mmfree;
src/lib/16_mm.c:	gvar->mm.mmfree=gvar->mm.mmfree->next;
src/lib/16_mm.c:	if(!(gvar->mm.mmnew=gvar->mm.mmfree))
src/lib/16_mm.c:	gvar->mm.mmfree=gvar->mm.mmfree->next;
src/lib/16_mm.c:	x->useptr=NULL;
src/lib/16_mm.c:	x->next=gvar->mm.mmfree;
src/lib/16_mm.c:	gvar->mm.mmfree=x;
src/lib/16_mm.c:	dword XMSDriver = gvar->pm.xmm.XMSDriver;
src/lib/16_mm.h: * Copyright (C) 1993-2014 Flat Rock Software
src/lib/16_mm.h: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_mm.h://#define GETNEWBLOCK {if(!(mmnew=mmfree))Quit("MM_GETNEWBLOCK: No free blocks!") ;mmfree=mmfree->next;}
src/lib/16_mm.h:#define GETNEWBLOCK {if(!gvar->mm.mmfree)MML_ClearBlock(gvar);gvar->mm.mmnew=gvar->mm.mmfree;gvar->mm.mmfree=gvar->mm.mmfree->next;}
src/lib/16_mm.h:#define FREEBLOCK(x) {*x->useptr=NULL;x->next=gvar->mm.mmfree;gvar->mm.mmfree=x;}
src/lib/16_mm.h://--------
src/lib/16_mm.h://--------
src/lib/16_mm.h:#define PURGEBITS	3		// 0-3 level, 0= unpurgable, 3= purge first
src/lib/16_mm.h:#define MAPPAGES		4//gvar->mm.EMSpagesmapped
src/lib/16_pm.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_pm.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_pm.c:	PMBlockAttr		gvar->pm.mm.MainMemUsed[PMMaxMainMem];
src/lib/16_pm.c:	int				gvar->pm.mm.MainPagesAvail;*/
src/lib/16_pm.c:/*	word			gvar->pm.emm.EMSAvail,gvar->pm.emm.EMSPagesAvail,gvar->pm.emm.EMSHandle,
src/lib/16_pm.c:					gvar->pm.emm.EMSPageFrame,gvar->pm.emm.EMSPhysicalPage;
src/lib/16_pm.c:	gvar->pm.emm.EMSListStruct	gvar->pm.emm.EMSList[EMSFrameCount];*/
src/lib/16_pm.c:	//word			gvar->pm.xmm.XMSAvail,gvar->pm.xmm.XMSPagesAvail,gvar->pm.xmm.XMSHandle;
src/lib/16_pm.c:/*	int				gvar->pm.xmm.XMSProtectPage = -1;
src/lib/16_pm.c:	char			gvar->pm.fi.PageFileName[13] = {"VSWAP."};
src/lib/16_pm.c:	int				PageFile = -1;
src/lib/16_pm.c:	word			gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:					gvar->pm.PMPanicMode,
src/lib/16_pm.c:					gvar->pm.PMThrashing;
src/lib/16_pm.c:	word			gvar->pm.XMSPagesUsed,
src/lib/16_pm.c:					gvar->pm.EMSPagesUsed,
src/lib/16_pm.c:					gvar->pm.PMNumBlocks;
src/lib/16_pm.c:	PageListStruct	far *gvar->pm.PMPages,
src/lib/16_pm.c:					_seg *gvar->pm.PMSegPages;*/
src/lib/16_pm.c://	PML_MapEMS() - Maps a logical page to a physical page
src/lib/16_pm.c:	EMShandle=gvar->pm.emm.EMSHandle;
src/lib/16_pm.c://	PML_StartupEMS() - Sets up EMS for Page Mgr's use
src/lib/16_pm.c:	gvar->pm.emm.EMSPresent = false;			// Assume that we'll fail
src/lib/16_pm.c:	gvar->pm.emm.EMSAvail = 0;
src/lib/16_pm.c:	gvar->mmi.EMSmem = 0;
src/lib/16_pm.c:		size = gvar->pm.emm.EMSAvail * (long)EMSPageSize;
src/lib/16_pm.c:		if (size - (EMSPageSize * 2) > (gvar->pm.fi.ChunksInFile * (long)PMPageSize))
src/lib/16_pm.c:			size = (gvar->pm.fi.ChunksInFile * (long)PMPageSize) + EMSPageSize;
src/lib/16_pm.c:			gvar->pm.emm.EMSAvail = size / EMSPageSize;
src/lib/16_pm.c:	gvar->mmi.EMSmem = EMSAvail * (dword)EMSPageSize;
src/lib/16_pm.c:		gvar->pm.emm.EMSList[i].baseEMSPage = -1;
src/lib/16_pm.c:		return(gvar->pm.emm.EMSPresent);
src/lib/16_pm.c:	gvar->pm.emm.EMSPresent = true;			// We have EMS
src/lib/16_pm.c:	gvar->pm.emm.EMSPageFrame = EMSPageFrame;
src/lib/16_pm.c:	gvar->pm.emm.EMSAvail = EMSAvail;
src/lib/16_pm.c:	gvar->pm.emm.EMSVer = EMSVer;
src/lib/16_pm.c:	gvar->pm.emm.EMSHandle = EMSHandle;
src/lib/16_pm.c:	gvar->pm.emm.freeEMSpages = freeEMSpages;
src/lib/16_pm.c:	gvar->pm.emm.totalEMSpages = totalEMSpages;
src/lib/16_pm.c:	return(gvar->pm.emm.EMSPresent);
src/lib/16_pm.c://	PML_ShutdownEMS() - If EMS was used, deallocate it
src/lib/16_pm.c:	EMSHandle=gvar->pm.emm.EMSHandle;
src/lib/16_pm.c:	if (gvar->pm.emm.EMSPresent)
src/lib/16_pm.c://	PML_StartupXMS() - Starts up XMS for the Page Mgr's use
src/lib/16_pm.c:	gvar->pm.xmm.XMSPresent = false;					// Assume failure
src/lib/16_pm.c:	XMSAvail = gvar->mmi.XMSmem = 0;
src/lib/16_pm.c:	XMSAvail &= ~(PMPageSizeKB - 1);	// Round off to nearest page size
src/lib/16_pm.c:		gvar->mmi.XMSmem = (dword)(XMSAvail) * 1024;
src/lib/16_pm.c:		gvar->pm.xmm.XMSAvail = XMSAvail;
src/lib/16_pm.c:		gvar->pm.xmm.XMSHandle = XMSHandle;
src/lib/16_pm.c:		//gvar->pm.xmm.XMSVer = XMSVer;
src/lib/16_pm.c:		gvar->pm.xmm.XMSPresent = true;
src/lib/16_pm.c:		printf("	XMSmem=%lu	XMSAvail=%u\n", gvar->mmi.XMSmem, XMSAvail);
src/lib/16_pm.c:		//printf("	%u", gvar->pm.xmm.XMSHandle);
src/lib/16_pm.c:	return(gvar->pm.xmm.XMSPresent);
src/lib/16_pm.c://	PML_XMSCopy() - Copies a main/EMS page to or from XMS
src/lib/16_pm.c://		Will round an odd-length request up to the next even value
src/lib/16_pm.c:	copy.source_handle = toxms? 0 : gvar->pm.xmm.XMSHandle;
src/lib/16_pm.c:	copy.target_handle = toxms? gvar->pm.xmm.XMSHandle : 0;
src/lib/16_pm.c://	PML_CopyToXMS() - Copies the specified number of bytes from the real mode
src/lib/16_pm.c://	PML_CopyFromXMS() - Copies the specified number of bytes from an XMS
src/lib/16_pm.c:	word XMSHandle = gvar->pm.xmm.XMSHandle;
src/lib/16_pm.c:	if (gvar->pm.xmm.XMSPresent)
src/lib/16_pm.c://	PM_SetMainMemPurge() - Sets the purge level for all allocated main memory
src/lib/16_pm.c://		blocks. This shouldn't be called directly - the PM_LockMainMem() and
src/lib/16_pm.c:	if(gvar->pm.mm.MainPresent)
src/lib/16_pm.c:		printf("PM_SetMainMemPurge()	info of gvar->pm.mm.MainMemPages[i]\n");
src/lib/16_pm.c:		printf("&	%Fp,	%Fp\n", &gvar->pm.mm.MainMemPages[i],	&(gvar->pm.mm.MainMemPages[i]));
src/lib/16_pm.c:		if (gvar->pm.mm.MainMemPages[i])
src/lib/16_pm.c:			MM_SetPurge(&(gvar->pm.mm.MainMemPages[i]),level, gvar);
src/lib/16_pm.c://	PM_CheckMainMem() - If something besides the Page Mgr makes requests of
src/lib/16_pm.c:	if (!gvar->pm.mm.MainPresent)
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:		n = page->mainPage;
src/lib/16_pm.c:		if (n != -1)						// Is the page using main memory?
src/lib/16_pm.c:			if (!gvar->pm.mm.MainMemPages[n])			// Yep, was the block purged?
src/lib/16_pm.c:				page->mainPage = -1;		// Yes, mark page as purged & unlocked
src/lib/16_pm.c:				page->locked = pml_Unlocked;
src/lib/16_pm.c:	for (i = 0,p = gvar->pm.mm.MainMemPages,used = gvar->pm.mm.MainMemUsed; i < PMMaxMainMem;i++,p++,used++)
src/lib/16_pm.c:				gvar->pm.mm.MainPagesAvail--;			// and decrease available count
src/lib/16_pm.c:				gvar->pm.MainPagesUsed--;			// and decrease used count
src/lib/16_pm.c:				if (gvar->mm.mmerror)					// If it failed,
src/lib/16_pm.c:					gvar->pm.mm.MainPagesAvail++;			// and increase available count
src/lib/16_pm.c:	if (gvar->mm.mmerror)
src/lib/16_pm.c:		gvar->mm.mmerror = false;
src/lib/16_pm.c://	PML_StartupMainMem() - Allocates as much main memory as is possible for
src/lib/16_pm.c://		the Page Mgr. The memory is allocated as non-purgeable, so if it's
src/lib/16_pm.c:	gvar->pm.mm.MainPagesAvail = 0;
src/lib/16_pm.c:	gvar->pm.mm.MainPresent = false;
src/lib/16_pm.c:	for (i = 0,p = gvar->pm.mm.MainMemPages;i < PMMaxMainMem;i++,p++)
src/lib/16_pm.c:		if (gvar->mm.mmerror)
src/lib/16_pm.c:		gvar->pm.mm.MainPagesAvail++;
src/lib/16_pm.c:		gvar->pm.mm.MainMemUsed[i] = pmba_Allocated;
src/lib/16_pm.c:	if (gvar->mm.mmerror)
src/lib/16_pm.c:		gvar->mm.mmerror = false;
src/lib/16_pm.c:	if (gvar->pm.mm.MainPagesAvail < PMMinMainMem)
src/lib/16_pm.c:	gvar->pm.mm.MainPresent = true;
src/lib/16_pm.c://	PML_ShutdownMainMem() - Frees all of the main memory blocks used by the
src/lib/16_pm.c:	// DEBUG - mark pages as unallocated & decrease page count as appropriate
src/lib/16_pm.c:	for (i = 0,p = gvar->pm.mm.MainMemPages;i < PMMaxMainMem;i++,p++)
src/lib/16_pm.c://	PML_ReadFromFile() - Reads some data in from the page file
src/lib/16_pm.c:	if (lseek(gvar->pm.fi.PageFile,offset,SEEK_SET) != offset)
src/lib/16_pm.c:	if (!CA_FarRead(gvar->pm.fi.PageFile,buf,length, gvar))
src/lib/16_pm.c://	PML_OpenPageFile() - Opens the page file and sets up the page info
src/lib/16_pm.c:	gvar->pm.fi.PageFile = open(gvar->pm.fi.PageFileName,O_RDONLY + O_BINARY);
src/lib/16_pm.c:	if (gvar->pm.fi.PageFile == -1)
src/lib/16_pm.c:	read(gvar->pm.fi.PageFile,&gvar->pm.fi.ChunksInFile,sizeof(gvar->pm.fi.ChunksInFile));
src/lib/16_pm.c:	read(gvar->pm.fi.PageFile,&gvar->pm.fi.PMSpriteStart,sizeof(gvar->pm.fi.PMSpriteStart));
src/lib/16_pm.c:	read(gvar->pm.fi.PageFile,&gvar->pm.fi.PMSoundStart,sizeof(gvar->pm.fi.PMSoundStart));
src/lib/16_pm.c:	gvar->pm.PMNumBlocks = gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:	MM_GetPtr((memptr *)gvar->pm.PMSegPages, sizeof(PageListStruct) * (gvar->pm.PMNumBlocks), gvar);
src/lib/16_pm.c:	MM_SetLock((memptr *)gvar->pm.PMSegPages,true, gvar);
src/lib/16_pm.c:	gvar->pm.PMPages = (PageListStruct far *)gvar->pm.PMSegPages;
src/lib/16_pm.c:	_fmemset(gvar->pm.PMPages,0,sizeof(PageListStruct) * gvar->pm.PMNumBlocks);
src/lib/16_pm.c:	size = sizeof(dword) * gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:	if (!CA_FarRead(gvar->pm.fi.PageFile,(byte far *)buf,size, gvar))
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:		page->offset = *offsetptr++;
src/lib/16_pm.c:	size = sizeof(word) * gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:	if (!CA_FarRead(gvar->pm.fi.PageFile,(byte far *)buf,size, gvar))
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:		page->length = *lengthptr++;
src/lib/16_pm.c://  PML_ClosePageFile() - Closes the page file
src/lib/16_pm.c:	if (gvar->pm.fi.PageFile != -1)
src/lib/16_pm.c:		close(gvar->pm.fi.PageFile);
src/lib/16_pm.c:	if (gvar->pm.PMSegPages)
src/lib/16_pm.c:		MM_SetLock((memptr)gvar->pm.PMSegPages,false, gvar);
src/lib/16_pm.c:		MM_FreePtr((memptr)gvar->pm.PMSegPages, gvar);
src/lib/16_pm.c:#pragma argsused	// DEBUG - remove lock parameter
src/lib/16_pm.c:	emsoff = page & (PMEMSSubPage - 1);
src/lib/16_pm.c:	emsbase = page - emsoff;
src/lib/16_pm.c:	emspage = -1;
src/lib/16_pm.c:		if (gvar->pm.emm.EMSList[i].baseEMSPage == emsbase)
src/lib/16_pm.c:			emspage = i;	// Yep - don't do a redundant remapping
src/lib/16_pm.c:	if (emspage == -1)
src/lib/16_pm.c:			if (gvar->pm.emm.EMSList[i].lastHit < last)
src/lib/16_pm.c:				last = gvar->pm.emm.EMSList[i].lastHit;
src/lib/16_pm.c:		gvar->pm.emm.EMSList[emspage].baseEMSPage = emsbase;
src/lib/16_pm.c:	if (emspage == -1)
src/lib/16_pm.c:	gvar->pm.emm.EMSList[emspage].lastHit = gvar->pm.PMFrameCount;
src/lib/16_pm.c:	return((memptr)(gvar->pm.emm.EMSPageFrame + offset));
src/lib/16_pm.c:	emspage = (lock < pml_EMSLock)? 3 : (lock - pml_EMSLock);
src/lib/16_pm.c:			+ ((page & (PMEMSSubPage - 1)) * PMPageSizeSeg)));
src/lib/16_pm.c://	PM_GetPageAddress() - Returns the address of a given page
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if (page->mainPage != -1)
src/lib/16_pm.c:		return(gvar->pm.mm.MainMemPages[page->mainPage]);
src/lib/16_pm.c:	else if (page->emsPage != -1)
src/lib/16_pm.c:		return(PML_GetEMSAddress(page->emsPage,page->locked, gvar));
src/lib/16_pm.c://	PML_GiveLRUPage() - Returns the page # of the least recently used
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages,lru = -1,last = LONG_MAX;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:			(page->lastHit < last)
src/lib/16_pm.c:		&&	((page->emsPage != -1) || (page->mainPage != -1))
src/lib/16_pm.c:		&& 	(page->locked == pml_Unlocked)
src/lib/16_pm.c:		&&	(!(mainonly && (page->mainPage == -1)))
src/lib/16_pm.c:			last = page->lastHit;
src/lib/16_pm.c:	if (lru == -1)
src/lib/16_pm.c://	PML_GiveLRUXMSPage() - Returns the page # of the least recently used
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages,lru = -1,last = LONG_MAX;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:			(page->xmsPage != -1)
src/lib/16_pm.c:		&&	(page->lastHit < last)
src/lib/16_pm.c:		&&	(i != gvar->pm.xmm.XMSProtectPage)
src/lib/16_pm.c:			last = page->lastHit;
src/lib/16_pm.c://	PML_PutPageInXMS() - If page isn't in XMS, find LRU XMS page and replace
src/lib/16_pm.c:	if (!gvar->pm.xmm.XMSPresent)
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if (page->xmsPage != -1)
src/lib/16_pm.c:	if (gvar->pm.XMSPagesUsed < gvar->pm.xmm.XMSPagesAvail)
src/lib/16_pm.c:		page->xmsPage = gvar->pm.XMSPagesUsed++;
src/lib/16_pm.c:		if (usexms == -1)
src/lib/16_pm.c:		page->xmsPage = gvar->pm.PMPages[usexms].xmsPage;
src/lib/16_pm.c:		gvar->pm.PMPages[usexms].xmsPage = -1;
src/lib/16_pm.c:	PML_CopyToXMS(PM_GetPageAddress(pagenum, gvar),page->xmsPage,page->length, gvar);
src/lib/16_pm.c://	PML_TransferPageSpace() - A page is being replaced, so give the new page
src/lib/16_pm.c:	origpage = &gvar->pm.PMPages[orig];
src/lib/16_pm.c:	newpage = &gvar->pm.PMPages[new];
src/lib/16_pm.c:	if (origpage->locked != pml_Unlocked)
src/lib/16_pm.c:	if ((origpage->emsPage == -1) && (origpage->mainPage == -1))
src/lib/16_pm.c:		Quit (gvar, "PML_TransferPageSpace: Reusing non-existent page");
src/lib/16_pm.c:	newpage->emsPage = origpage->emsPage;
src/lib/16_pm.c:	newpage->mainPage = origpage->mainPage;
src/lib/16_pm.c:	origpage->mainPage = origpage->emsPage = -1;
src/lib/16_pm.c://	PML_GetAPageBuffer() - A page buffer is needed. Either get it from the
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if ((gvar->pm.EMSPagesUsed < gvar->pm.emm.EMSPagesAvail) && !mainonly)
src/lib/16_pm.c:		// There's remaining EMS - use it
src/lib/16_pm.c:		page->emsPage = gvar->pm.EMSPagesUsed++;
src/lib/16_pm.c:		addr = PML_GetEMSAddress(page->emsPage,page->locked, gvar);
src/lib/16_pm.c:	else if (gvar->pm.MainPagesUsed < gvar->pm.mm.MainPagesAvail)
src/lib/16_pm.c:		// There's remaining main memory - use it
src/lib/16_pm.c:		for (i = 0,n = -1,used = gvar->pm.mm.MainMemUsed;i < PMMaxMainMem;i++,used++)
src/lib/16_pm.c:		if (n == -1)
src/lib/16_pm.c:		addr = gvar->pm.mm.MainMemPages[n];
src/lib/16_pm.c:		page->mainPage = n;
src/lib/16_pm.c:		gvar->pm.MainPagesUsed++;
src/lib/16_pm.c://	PML_GetPageFromXMS() - If page is in XMS, find LRU main/EMS page and
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if (gvar->pm.xmm.XMSPresent && (page->xmsPage != -1))
src/lib/16_pm.c:		gvar->pm.xmm.XMSProtectPage = pagenum;
src/lib/16_pm.c:		PML_CopyFromXMS(addr,page->xmsPage,page->length, gvar);
src/lib/16_pm.c:		gvar->pm.xmm.XMSProtectPage = -1;
src/lib/16_pm.c://	PML_LoadPage() - A page is not in main/EMS memory, and it's not in XMS.
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	PML_ReadFromFile(addr,page->offset,page->length, gvar);
src/lib/16_pm.c://	PM_GetPage() - Returns the address of the page, loading it if necessary
src/lib/16_pm.c:#pragma warn -pia
src/lib/16_pm.c:	if (pagenum >= gvar->pm.fi.ChunksInFile)
src/lib/16_pm.c:		boolean mainonly = (pagenum >= gvar->pm.fi.PMSoundStart);
src/lib/16_pm.c:if (!gvar->pm.PMPages[pagenum].offset)	// JDC: sparse page
src/lib/16_pm.c:			if (gvar->pm.PMPages[pagenum].lastHit ==  gvar->pm.PMFrameCount)
src/lib/16_pm.c:				gvar->pm.PMThrashing++;
src/lib/16_pm.c:	gvar->pm.PMPages[pagenum].lastHit =  gvar->pm.PMFrameCount;
src/lib/16_pm.c://	PM_SetPageLock() - Sets the lock type on a given page
src/lib/16_pm.c:	if (pagenum < gvar->pm.fi.PMSoundStart)
src/lib/16_pm.c:		Quit (gvar, "PM_SetPageLock: Locking/unlocking non-sound page");
src/lib/16_pm.c:	gvar->pm.PMPages[pagenum].locked = lock;
src/lib/16_pm.c://	PM_Preload() - Loads as many pages as possible into all types of memory.
src/lib/16_pm.c:	mainfree = (gvar->pm.mm.MainPagesAvail - gvar->pm.MainPagesUsed) + (gvar->pm.emm.EMSPagesAvail - gvar->pm.EMSPagesUsed);
src/lib/16_pm.c:	xmsfree = (gvar->pm.xmm.XMSPagesAvail - gvar->pm.XMSPagesUsed);
src/lib/16_pm.c:	for (i = 0;i < gvar->pm.fi.ChunksInFile;i++)
src/lib/16_pm.c:		if (!gvar->pm.PMPages[i].offset)
src/lib/16_pm.c:		if ( gvar->pm.PMPages[i].emsPage != -1 || gvar->pm.PMPages[i].mainPage != -1 )
src/lib/16_pm.c:			mainfree--;
src/lib/16_pm.c:		else if ( xmsfree && (gvar->pm.PMPages[i].xmsPage == -1) )
src/lib/16_pm.c:			xmsfree--;
src/lib/16_pm.c:		while ( !gvar->pm.PMPages[page].offset || gvar->pm.PMPages[page].mainPage != -1
src/lib/16_pm.c:			||	gvar->pm.PMPages[page].emsPage != -1 )
src/lib/16_pm.c:		if (page >= gvar->pm.fi.ChunksInFile)
src/lib/16_pm.c:			Quit (gvar, "PM_Preload: Pages>=gvar->pm.fi.ChunksInFile");
src/lib/16_pm.c:		maintotal--;
src/lib/16_pm.c:		for (oogypage = 0 ; gvar->pm.PMPages[oogypage].mainPage == -1 ; oogypage++)
src/lib/16_pm.c:			while ( !gvar->pm.PMPages[page].offset || gvar->pm.PMPages[page].xmsPage != -1 )
src/lib/16_pm.c:			if (page >= gvar->pm.fi.ChunksInFile)
src/lib/16_pm.c:				Quit (gvar, "PM_Preload: Pages>=gvar->pm.fi.ChunksInFile");
src/lib/16_pm.c:			p = &gvar->pm.PMPages[page];
src/lib/16_pm.c:			p->xmsPage = gvar->pm.XMSPagesUsed++;
src/lib/16_pm.c:			if (gvar->pm.XMSPagesUsed > gvar->pm.xmm.XMSPagesAvail)
src/lib/16_pm.c:			if (p->length > PMPageSize)
src/lib/16_pm.c:			PML_ReadFromFile((byte far *)addr,p->offset,p->length, gvar);
src/lib/16_pm.c:			PML_CopyToXMS((byte far *)addr,p->xmsPage,p->length, gvar);
src/lib/16_pm.c:			xmstotal--;
src/lib/16_pm.c:		p = &gvar->pm.PMPages[oogypage];
src/lib/16_pm.c:		PML_ReadFromFile((byte far *)addr,p->offset,p->length, gvar);
src/lib/16_pm.c://	PM_NextFrame() - Increments the frame counter and adjusts the thrash
src/lib/16_pm.c:	// Frame count overrun - kill the LRU hit entries & reset frame count
src/lib/16_pm.c:	if (++gvar->pm.PMFrameCount >= LONG_MAX - 4)
src/lib/16_pm.c:		for (i = 0;i < gvar->pm.PMNumBlocks;i++)
src/lib/16_pm.c:			gvar->pm.PMPages[i].lastHit = 0;
src/lib/16_pm.c:		gvar->pm.PMFrameCount = 0;
src/lib/16_pm.c:	for (i = 0;i < gvar->pm.fi.PMSoundStart;i++)
src/lib/16_pm.c:		if (gvar->pm.PMPages[i].locked)
src/lib/16_pm.c:	if (gvar->pm.PMPanicMode)
src/lib/16_pm.c:		// DEBUG - set border color
src/lib/16_pm.c:		if ((!gvar->pm.PMThrashing) && (!--gvar->pm.PMPanicMode))
src/lib/16_pm.c:			// DEBUG - reset border color
src/lib/16_pm.c:	if (gvar->pm.PMThrashing >= PMThrashThreshold)
src/lib/16_pm.c:		gvar->pm.PMPanicMode = PMUnThrashThreshold;
src/lib/16_pm.c:	gvar->pm.PMThrashing = false;
src/lib/16_pm.c://	PM_Reset() - Sets up caching structures
src/lib/16_pm.c:	gvar->pm.xmm.XMSPagesAvail = gvar->pm.xmm.XMSAvail / PMPageSizeKB;
src/lib/16_pm.c:	gvar->pm.emm.EMSPagesAvail = gvar->pm.emm.EMSAvail * (EMSPageSizeKB / PMPageSizeKB);
src/lib/16_pm.c:	gvar->pm.emm.EMSPhysicalPage = 0;
src/lib/16_pm.c:	gvar->pm.MainPagesUsed = gvar->pm.EMSPagesUsed = gvar->pm.XMSPagesUsed = 0;
src/lib/16_pm.c:	gvar->pm.PMPanicMode = false;
src/lib/16_pm.c:	gvar->pm.fi.PageFile = -1;
src/lib/16_pm.c:	gvar->pm.xmm.XMSProtectPage = -1;
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.PMNumBlocks;i++,page++)
src/lib/16_pm.c:		page->mainPage = -1;
src/lib/16_pm.c:		page->emsPage = -1;
src/lib/16_pm.c:		page->xmsPage = -1;
src/lib/16_pm.c:		page->locked = false;
src/lib/16_pm.c://	PM_Startup() - Start up the Page Mgr
src/lib/16_pm.c:	if (gvar->pm.PMStarted)
src/lib/16_pm.c:	//0000+=+=strcpy(&(gvar->pm.fi.PageFileName), "VSWAP.");
src/lib/16_pm.c:	if (!gvar->pm.mm.MainPresent && !gvar->pm.emm.EMSPresent && !gvar->pm.xmm.XMSPresent)
src/lib/16_pm.c:	gvar->pm.PMStarted = true;
src/lib/16_pm.c://	PM_Shutdown() - Shut down the Page Mgr
src/lib/16_pm.c:	if (!gvar->pm.PMStarted)
src/lib/16_pm.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_pm.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_pm.h:#define	PMUnThrashThreshold	5	// Number of non-thrashing frames before leaving panic mode
src/lib/16render.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16render.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16render.c:	#define PEEE	rx-prw
src/lib/16render.c:	#define PE		(p->pwidth)
src/lib/16render.c:	if(rh<p->height) prh = (PE*(ry-4));
src/lib/16render.c:	else if(rh==p->height) prh = (PE*(ry));
src/lib/16render.c:		modexSelectPlane(PLANE(plane-1));
src/lib/16render.c:				_fmemcpy(page->data + (((page->width/4) * (y)) + ((x) / 4)), &(p->plane[plane][i]), prw);
src/lib/16render.c:	modexDrawPBufRegion	(page, x, x, 0, 0, p->width, p->height, p, sprite);
src/lib/16render.c:// 	buff = _nmalloc(p->pwidth+1);
src/lib/16render.c:// 		for(px = plane; px < p->width; px+=4) {
src/lib/16render.c:// 			for(py=0; py<p->height/2; py++) {
src/lib/16render.c:// 				if(!sprite || p->plane[offset])
src/lib/16render.c:// 					page->data = &(p->plane[offset][i++]);
src/lib/16render.c:// 				offset+=p->width;
src/lib/16render.c:		modexSelectPlane(PLANE(plane-1));
src/lib/16render.c:		for(; y < py+p->height; y++) {
src/lib/16render.c:			//for(px=0; px < p->width; px++) {
src/lib/16render.c:				//printf("%02X ", (int) p->plane[plane][i++]);
src/lib/16render.c://				_fmemcpy(buff, &(p->plane[plane][i+=p->pwidth]), p->pwidth);
src/lib/16render.c://				_fmemcpy(page->data + (((page->width/4) * (y+page[0].dy)) + ((x+page[0].dx) / 4)), buff, p->pwidth);
src/lib/16render.c:				_fmemcpy(page->data + (((page->width/4) * y) + (x / 4)), &(p->plane[plane][i+=p->pwidth]), p->pwidth);
src/lib/16render.c:		for(px = plane; px < bmp->width; px+=4) {
src/lib/16render.c:			for(py=0; py<bmp->height; py++) {
src/lib/16render.c:			if(!sprite || bmp->data[offset])
src/lib/16render.c:				page[PAGE_OFFSET(x+px, y+py)] = bmp->data[offset];
src/lib/16render.c:			offset+=bmp->width;
src/lib/16render.c:    modexDrawBmpRegion(page, x, y, 0, 0, bmp->width, bmp->height, bmp);
src/lib/16render.c:	word poffset = (word) page->data  + y*(page->width/4) + x/4;
src/lib/16render.c:	byte *data = bmp->data;//+bmp->offset;
src/lib/16render.c:	word bmpOffset = (word) data + ry * bmp->width + rx;
src/lib/16render.c:	word nextPageRow = page->width/4 - scanCount;
src/lib/16render.c:	word nextBmpRow = (word) bmp->width - width;
src/lib/16render.c:		;-- begin plane painting
src/lib/16render.c:		;-- end plane painting
src/lib/16render.c:    modexDrawSpriteRegion(page, x, y, 0, 0, bmp->width, bmp->height, bmp);
src/lib/16render.c:	word poffset = (word)page->data + y*(page->width/4) + x/4;
src/lib/16render.c:	byte *data = bmp->data;//+bmp->offset;
src/lib/16render.c:	word bmpOffset = (word) data + ry * bmp->width + rx;
src/lib/16render.c:	word nextPageRow = page->width/4 - scanCount;
src/lib/16render.c:	word nextBmpRow = (word) bmp->width - width;
src/lib/16render.c:		;-- begin plane painting
src/lib/16render.c:		JNE DRAW_PIXEL	  ; draw non-zero pixels
src/lib/16render.c:		;-- end plane painting
src/lib/16render.c:    modexDrawBmpPBufRegion(page, x, y, 0, 0, bmp->width, bmp->height, bmp);
src/lib/16render.c:	word poffset = (word) page->data  + y*(page->width/4) + x/4;
src/lib/16render.c:	byte *data = bmp->plane[0];
src/lib/16render.c:	word bmpOffset = (word) data + ry * bmp->width + rx;
src/lib/16render.c:	word nextPageRow = page->width/4 - scanCount;
src/lib/16render.c:	word nextBmpRow = (word) bmp->width - width;
src/lib/16render.c:		;-- begin plane painting
src/lib/16render.c:		;-- end plane painting
src/lib/16render.c:    modexDrawSpritePBufRegion(page, x, y, 0, 0, bmp->width, bmp->height, bmp);
src/lib/16render.c:	word poffset = (word)page->data + y*(page->width/4) + x/4;
src/lib/16render.c:	byte *data = bmp->plane[0];
src/lib/16render.c:	word bmpOffset = (word) data + ry * bmp->width + rx;
src/lib/16render.c:	word nextPageRow = page->width/4 - scanCount;
src/lib/16render.c:	word nextBmpRow = (word) bmp->width - width;
src/lib/16render.c:		;-- begin plane painting
src/lib/16render.c:		JNE DRAW_PIXEL	  ; draw non-zero pixels
src/lib/16render.c:		;-- end plane painting
src/lib/16render.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16render.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_snd.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_snd.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_snd.c:*     Parameters:        voice - which voice to turn off.
src/lib/16_snd.c:*     Parameters:        voice - which voice to turn on.
src/lib/16_snd.c:*                         freq - its frequency (note).
src/lib/16_snd.c:*                         octave - its octave.
src/lib/16_snd.c:*     Parameters:        voiceNum - which voice to set.
src/lib/16_snd.c:*                         ins - instrument to set voice.
src/lib/16_snd.c:	opl2out(opCellNum, ins->SoundCharacteristic[0]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->SoundCharacteristic[1]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->Level[0]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->Level[1]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->AttackDecay[0]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->AttackDecay[1]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->SustainRelease[0]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->SustainRelease[1]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->WaveSelect[0]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->WaveSelect[1]);
src/lib/16_snd.c:	opl2out(opCellNum, ins->Feedback);
src/lib/16_snd.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_snd.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_snd.h:* FM Instrument definition for .SBI files - SoundBlaster instrument
src/lib/16_snd.h:* - these are the important parts - we will skip the header, but since
src/lib/16_sprit.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_sprit.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_sprit.c:	struct vrs_header far *vrs = spri->spritesheet->vrs_hdr;
src/lib/16_sprit.c:						 vrs->offset_table[VRS_HEADER_OFFSET_ANIMATION_NAME_LIST]);
src/lib/16_sprit.c:	return (char *)(vrs + anim_names_offsets[spri->curr_anim]);
src/lib/16_sprit.c:	struct vrs_header far *vrs = spri->spritesheet->vrs_hdr;
src/lib/16_sprit.c:						 vrs->offset_table[VRS_HEADER_OFFSET_ANIMATION_LIST]);
src/lib/16_sprit.c:	spri->curr_anim = anim_index;
src/lib/16_sprit.c:	spri->curr_anim_spri = 0;
src/lib/16_sprit.c:	spri->curr_spri_id = anim_list[0].sprite_id;
src/lib/16_sprit.c:	spri->delay = anim_list[0].delay;
src/lib/16_sprit.c:	spri->curr_anim_list = anim_list;
src/lib/16_sprit.c:	struct vrs_header far *vrs = spri->spritesheet->vrs_hdr;
src/lib/16_sprit.c:					 vrs->offset_table[VRS_HEADER_OFFSET_ANIMATION_ID_LIST]);
src/lib/16_sprit.c:	return -1;
src/lib/16_sprit.c:	struct vrs_header far *vrs = spri->spritesheet->vrs_hdr;
src/lib/16_sprit.c:					 vrs->offset_table[VRS_HEADER_OFFSET_ANIMATION_ID_LIST]);
src/lib/16_sprit.c:	i = get_vrl_by_id(spri->spritesheet, spri->curr_spri_id, spri->sprite_vrl_cont);
src/lib/16_sprit.c:	draw_vrl1_vgax_modex(	spri->x,// - spri->sprite_vrl_cont->vrl_header->width-28,
src/lib/16_sprit.c:					spri->y,// - spri->sprite_vrl_cont->vrl_header->height*2 -(gv->video.page[0].sh/2),
src/lib/16_sprit.c:				spri->sprite_vrl_cont->vrl_header, spri->sprite_vrl_cont->line_offsets,
src/lib/16_sprit.c:				spri->sprite_vrl_cont->buffer + sizeof(struct vrl1_vgax_header),
src/lib/16_sprit.c:				spri->sprite_vrl_cont->data_size);
src/lib/16_sprit.c:	switch(spri->delay){
src/lib/16_sprit.c:			spri->curr_anim_spri++;
src/lib/16_sprit.c:			if(!(spri->curr_spri_id = spri->curr_anim_list[spri->curr_anim_spri].sprite_id)){
src/lib/16_sprit.c:				spri->curr_anim_spri = 0;
src/lib/16_sprit.c:				spri->curr_spri_id = spri->curr_anim_list[spri->curr_anim_spri].sprite_id;
src/lib/16_sprit.c:			spri->delay = spri->curr_anim_list[spri->curr_anim_spri].delay;
src/lib/16_sprit.c:			spri->delay--;
src/lib/16_sprit.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_sprit.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_sprit.h:* + struct sprite *spri - sprite to retrive current animation sequence name from
src/lib/16_sprit.h:* + char* - animation sequence name
src/lib/16_sprit.h: * struct sprite *spri - sprite to manipulate on
src/lib/16_sprit.h: * int id - id of a new animation sequence of th sprite
src/lib/16_sprit.h: * int - 0 on success, -1 on error
src/lib/16_sprit.h: * + struct sprite *spri - sprite to animate
src/lib/16_tail.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_tail.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_tail.c:	// NTS: I can see from the makefile Sparky4 intends this to run on 8088 by the -0 switch in CFLAGS.
src/lib/16_tail.c:	//      the CPU to carry out tasks. --J.C.
src/lib/16_tail.c:	_DEBUG("Serial debug output started\n"); // NTS: All serial output must end messages with newline, or DOSBox-X will not emit text to log
src/lib/16_tail.c:	gvar->mm.mmstarted=0;
src/lib/16_tail.c:	gvar->pm.PMStarted=0;
src/lib/16_tail.c:	if ( (file = open(configname,O_BINARY | O_RDONLY)) != -1)
src/lib/16_tail.c:	if (file != -1)
src/lib/16_tail.c:	US_CPrint ("------------");
src/lib/16_tail.c:	printf("------------\n"); }else printf("	%c%c", 0xD3, 0xC4);
src/lib/16_tail.c:	printf("Total:	"); if(q) printf("	"); printf("%uk", gvar->mmi.mainmem/1024);
src/lib/16_tail.c:	if(q) printf("------------\n");
src/lib/16_tail.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_tail.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_tdef.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_tdef.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_tdef.h:#define	PMUnThrashThreshold	5	// Number of non-thrashing frames before leaving panic mode
src/lib/16_tdef.h:	int				XMSProtectPage;// = -1;
src/lib/16_tdef.h:	int				PageFile;// = -1;
src/lib/16_tdef.h:  word bit0,bit1;	// 0-255 is a character, > is a pointer to a node
src/lib/16text.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16text.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16text.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16text.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_t.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_t.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_t.h:typedef void _seg * memptr;//typedef void __based( void ) * memptr;	////old //----typedef void __based(__self) * memptr;
src/lib/16_t.h://from http://stackoverflow.com/questions/18425748/gotoxy-function-using-printf-s-position
src/lib/16_timer.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_timer.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_timer.c:	gv->kurokku.t = clock();
src/lib/16_timer.c:	gv->kurokku.tiku = 0;
src/lib/16_timer.c:	gv->kurokku.clock_start = *clockw;
src/lib/16_timer.c:	gv->kurokku.clock = clockw;
src/lib/16_timer.c:	//gv->kurokku.frames_per_second = 60;
src/lib/16_timer.c:			gv->kurokku.fpscap=0;
src/lib/16_timer.c:			gv->kurokku.frames_per_second=1;
src/lib/16_timer.c:			gv->kurokku.fpscap=1;
src/lib/16_timer.c:			gv->kurokku.frames_per_second=60;
src/lib/16_timer.c:	return gv->kurokku.t;
src/lib/16_timer.c:	return (clock() - gv->kurokku.t) / CLOCKS_PER_SEC;
src/lib/16_timer.c:	clocku = (clock() - gv->kurokku.t) / CLOCKS_PER_SEC;
src/lib/16_timer.c:	gv->kurokku.t = clock();
src/lib/16_timer.c:	return (gv->kurokku.t) / CLOCKS_PER_SEC;
src/lib/16_timer.c:	if(elapsed_timer(gv) >= (1.0 / gv->kurokku.frames_per_second))
src/lib/16_timer.c:		//t=(((*(gv->clock))-gv->clock_start) /18.2);
src/lib/16_timer.c:		sprintf(global_temp_status_text, "%.0f fps", (double)gv->kurokku.tiku/ticktock(gv));
src/lib/16_timer.c:		//(gv->clock_start)=*(gv->clock);
src/lib/16_timer.c:		gv->kurokku.tiku=0;
src/lib/16_timer.c:	gv->kurokku.tiku++;
src/lib/16_timer.c:// 	switch(gv->kurokku.fpscap)
src/lib/16_timer.c:// 			gv->kurokku.frames_per_second=1;
src/lib/16_timer.c:// 			gv->kurokku.frames_per_second=60;
src/lib/16_timer.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_timer.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_vl.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_vl.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_vl.c:// setvideo() - This function Manages the video modes												//
src/lib/16_vl.c:			in.h.al = gv->video.old_mode;
src/lib/16_vl.c:			gv->video.old_mode = vgaGetMode();//out.h.al;
src/lib/16_vl.c://---------------------------------------------------
src/lib/16_vl.c:byte/*FIXME: why long? "long" is 32-bit datatype, VGA modes are 8-bit numbers. */
src/lib/16_vl.c:/* -========================= Entry  Points ==========================- */
src/lib/16_vl.c:			gv->video.page[0].sw = vga_state.vga_width = 320; // VGA lib currently does not update this
src/lib/16_vl.c:			gv->video.page[0].sh = vga_state.vga_height = 240; // VGA lib currently does not update this
src/lib/16_vl.c:			gv->video.page[0].height = gv->video.page[0].sh;
src/lib/16_vl.c:			gv->video.page[0].width = gv->video.page[0].sw;
src/lib/16_vl.c:			cm.horizontal_total=0x5f + 5; /* CRTC[0]			 -5 */
src/lib/16_vl.c:			cm.horizontal_display_end=0x4f + 1; /* CRTC[1]	   -1 */
src/lib/16_vl.c://			cm.horizontal_blank_end=0x82 + 1;   /* CRTC[3] bit 0-4 & CRTC[5] bit 7 *///skewing ^^;
src/lib/16_vl.c:			cm.horizontal_end_retrace=0x80;	/* CRTC[5] bit 0-4 */
src/lib/16_vl.c:			//cm.horizontal_start_delay_after_total=0x3e; /* CRTC[3] bit 5-6 */
src/lib/16_vl.c:			//cm.horizontal_start_delay_after_retrace=0x41; /* CRTC[5] bit 5-6 */
src/lib/16_vl.c://	gv->video.page[0].tw = gv->video.page[0].sw/TILEWH;
src/lib/16_vl.c://	gv->video.page[0].th = gv->video.page[0].sh/TILEWH;
src/lib/16_vl.c://	gv->video.page[0].tilemidposscreenx = gv->video.page[0].tilesw;
src/lib/16_vl.c://	gv->video.page[0].tilemidposscreeny = (gv->video.page[0].tilesh/2)+1;
src/lib/16_vl.c:	page.sw = p->sw;
src/lib/16_vl.c:	page.sh = p->sh;
src/lib/16_vl.c:	page.width = p->sw+TILEWHD;
src/lib/16_vl.c:	page.height = p->sh+TILEWHD;
src/lib/16_vl.c:	result.data = p->data + (p->pagesize);
src/lib/16_vl.c:	result.dx = p->dx;	// not used anymore we use page[0].dx
src/lib/16_vl.c:	result.dy = p->dy;	// not used anymore we use page[0].dy
src/lib/16_vl.c:	result.sw = p->sw;
src/lib/16_vl.c:	result.sh = p->sh;
src/lib/16_vl.c:	result.width = p->width;
src/lib/16_vl.c:	result.height = p->height;
src/lib/16_vl.c:	result.tw = p->tw;
src/lib/16_vl.c:	result.th = p->th;
src/lib/16_vl.c:	result.tilesw = p->tilesw;
src/lib/16_vl.c:	result.tilesh = p->tilesh;
src/lib/16_vl.c:	result.stridew=p->stridew;
src/lib/16_vl.c:	result.pagesize = p->pagesize;
src/lib/16_vl.c:	result.id = p->id+1;
src/lib/16_vl.c:	result.data = p->data + (p->pagesize);  /* compute the offset */
src/lib/16_vl.c:	result.id = p->id+1;
src/lib/16_vl.c:	result.stridew=p->sw/4;//result.width/4;
src/lib/16_vl.c:			result.pi=p->width*4;
src/lib/16_vl.c:			result.pi=p->pi;
src/lib/16_vl.c:	//printf("\n\n	1st vmem_remain=%u\n", video->vmem_remain);
src/lib/16_vl.c:	for(i=0; i<video->num_of_pages; i++)
src/lib/16_vl.c:		video->vmem_remain-=video->page[i].pagesize;
src/lib/16_vl.c:		//printf("		[%u], video->page[%u].pagesize=%u\n", i, i, video->page[i].pagesize);
src/lib/16_vl.c:		//printf("		[%u], vmem_remain=%u\n", i, video->vmem_remain);
src/lib/16_vl.c:	video->vmem_remain=65535U;
src/lib/16_vl.c:	video->num_of_pages=0;
src/lib/16_vl.c:	(video->page[0]) = modexDefaultPage(&(video->page[0]));	video->num_of_pages++;	//video->page[0].width += (TILEWHD); video->page[0].height += (TILEWHD);
src/lib/16_vl.c:	(video->page[1]) = modexNextPage(&(video->page[0]));	video->num_of_pages++;
src/lib/16_vl.c://0000	(video->page[2]) = modexNextPageFlexibleSize(&(video->page[1]), (video->page[0]).width, TILEWH*4);		video->num_of_pages++;
src/lib/16_vl.c://0000	(video->page[3]) = (video->page[2]);		video->num_of_pages++;
src/lib/16_vl.c:	(video->page[2]) = modexNextPageFlexibleSize(&(video->page[1]), TILEWH*4, TILEWH*4);		video->num_of_pages++;
src/lib/16_vl.c://	(video->page[3]) = modexNextPageFlexibleSize(&(video->page[2]), video->page[0].width, 176);	video->num_of_pages++;
src/lib/16_vl.c:	(video->page[3]) = modexNextPageFlexibleSize(&(video->page[2]), video->page[0].sw, 208);	video->num_of_pages++;
src/lib/16_vl.c:// 	(video->page[2]) = modexNextPageFlexibleSize(&(video->page[1]), video->page[0].width, 172);	video->num_of_pages++;
src/lib/16_vl.c:// 	(video->page[3]) = modexNextPageFlexibleSize(&(video->page[2]), 72, 128);		video->num_of_pages++;
src/lib/16_vl.c:	video->p=0;
src/lib/16_vl.c:	video->r=1;
src/lib/16_vl.c:	video->page[0].dy=video->page[0].dx=TILEWH;
src/lib/16_vl.c:	/*	video->page[1].dx=video->page[1].dy=TILEWH;	// 1 tile size buffer
src/lib/16_vl.c:	video->page[2].dx=video->page[2].dy=
src/lib/16_vl.c:		video->page[3].dx=video->page[3].dy=0;		*/// cache pages are buffer wwww
src/lib/16_vl.c:	offset = (word) page->data;
src/lib/16_vl.c:	offset += page[0].dy * (page->width >> 2 );
src/lib/16_vl.c:	crtcOffset = page->width >> 3;
src/lib/16_vl.c:	offset = (word) page->data;
src/lib/16_vl.c:	offset += page[0].dy * (page->width >> 2 );
src/lib/16_vl.c:	crtcOffset = page->sw >> 3;
src/lib/16_vl.c:	offset = (word) page->data;
src/lib/16_vl.c:	offset += page[0].dy * (page->width >> 2 );
src/lib/16_vl.c:	crtcOffset = page->width >> 3;
src/lib/16_vl.c:	word pageOff = (word) page->data;
src/lib/16_vl.c:	word poffset = pageOff + y*(page->stridew) + xoff; /* starting offset */
src/lib/16_vl.c:	word nextRow = page->stridew-scanCount-1;  /* loc of next row */
src/lib/16_vl.c:		;-- write the main body of the scanline
src/lib/16_vl.c:	word doffset = (word)dest->data + dy*(dest->stridew) + dx/4;
src/lib/16_vl.c:	word soffset = (word)src->data + sy*(src->stridew) + sx/4;
src/lib/16_vl.c:	word nextSrcRow = src->stridew - scans - 1;
src/lib/16_vl.c:	word nextDestRow = dest->stridew - scans - 1;
src/lib/16_vl.c://	printf("modexCopyPageRegion(src->stridew=%u, dest->stridew=%u, sx=%u, sy=%u, dx=%u, dy=%u, width=%u, height=%u, left=%u, right=%u)\n", src->stridew, dest->stridew, sx, sy, dx, dy, width, height, left, right);
src/lib/16_vl.c:	fadePalette(-fade, 64, 64/fade+1, palette);
src/lib/16_vl.c:	fadePalette(fade, -64, 64/fade+1, palette);
src/lib/16_vl.c:	fadePalette(-fade, 0, 64/fade+1, palette);
src/lib/16_vl.c:		tmppal[i] = palette[i] - dim;
src/lib/16_vl.c:	iter--;
src/lib/16_vl.c:	exit(-1);
src/lib/16_vl.c:	exit(-2);
src/lib/16_vl.c:	exit(-2);
src/lib/16_vl.c:	fadePalette(-1, 64, 1, tmppal);
src/lib/16_vl.c:	fadePalette(-1, -64, 1, tmppal);
src/lib/16_vl.c:	byte *p = bmp->palette;
src/lib/16_vl.c:		memset(a, -1, sizeof(a));
src/lib/16_vl.c:		//printf("	  (*i)-q=%02d\n", (*i)-q);
src/lib/16_vl.c://____		  if((qp>0)&&((*i)-q)%3==0 && (p[((*i)-q)]==p[((*i)-q)+3] && p[((*i)-q)+1]==p[((*i)-q)+4] && p[((*i)-q)+2]==p[((*i)-q)+5])) outp(PAL_DATA_REG, p[(*i)-q]); else
src/lib/16_vl.c:			if(((((*i)-q)%3==0)) && (p[((*i)-q)]==p[((*i)-q)+3] && p[((*i)-q)+1]==p[((*i)-q)+4] && p[((*i)-q)+2]==p[((*i)-q)+5]))
src/lib/16_vl.c:				printf("		%d's color=%d\n", (*i), (a[qp])-(bmp->offset*3)+qp);
src/lib/16_vl.c:				//outp(PAL_DATA_REG, p[((a[qp])-(bmp->offset*3)+qp)]);// fix this shit!
src/lib/16_vl.c:				if(bmp->offset==0 && (*i)<3 && q==0) outp(PAL_DATA_REG, 0);
src/lib/16_vl.c:				if(qp==0) outp(PAL_DATA_REG, p[(*i)-q]);
src/lib/16_vl.c:				else{ //outp(PAL_DATA_REG, p[((*i)-(bmp->offset*3)+qp)]);
src/lib/16_vl.c:				printf("p[]=%d  qp=%d   p[]-qp=%d\n", ((*i)-(bmp->offset*3)), qp, ((*i)-(bmp->offset*3))+qp); }
src/lib/16_vl.c:	//modexWaitBorder();	  /* waits one retrace -- less flicker */
src/lib/16_vl.c://____		  if((qp>0)&&((*i)-q)%3==0 && (p[((*i)-q)]==p[((*i)-q)+3] && p[((*i)-q)+1]==p[((*i)-q)+4] && p[((*i)-q)+2]==p[((*i)-q)+5])) outp(PAL_DATA_REG, p[(*i)-q]); else
src/lib/16_vl.c:			if(((((*i)-q)%3==0)) && (p[((*i)-q)]==p[((*i)-q)+3] && p[((*i)-q)+1]==p[((*i)-q)+4] && p[((*i)-q)+2]==p[((*i)-q)+5]))
src/lib/16_vl.c:				printf("		%d's color=%d\n", (*i), (a[qp]-(bmp->offset*3)+qp));
src/lib/16_vl.c:				//outp(PAL_DATA_REG, p[((a[qp])-(bmp->offset*3)+qp)]);// fix this shit!
src/lib/16_vl.c:				if(qp==0) outp(PAL_DATA_REG, p[(*i)-q]);
src/lib/16_vl.c:				else{ //outp(PAL_DATA_REG, p[((*i)-(bmp->offset*3)+qp)]);
src/lib/16_vl.c:				printf("p[]=%d  qp=%d   p[]-qp=%d\n", ((*i)-(bmp->offset*3)), qp, ((*i)-(bmp->offset*3))+qp); }
src/lib/16_vl.c:		long bufSize = (bmp->width * bmp->height);
src/lib/16_vl.c:			if(a[aq]==-1) aq++;
src/lib/16_vl.c:									use a[qp] instead of bmp->offset for this spot!
src/lib/16_vl.c:		//(offset/bmp->offset)*bmp->offset
src/lib/16_vl.c:		//printf("%02d ",bmp->data[lq]+bmp->offset);
src/lib/16_vl.c:		//if(lq > 0 && lq%bmp->width==0) printf("\n");
src/lib/16_vl.c:		//printf("%02d_", bmp->data[lq]+bmp->offset);
src/lib/16_vl.c:		/*if(bmp->data[lq]+bmp->offset==aq)
src/lib/16_vl.c:			//printf("%02d", bmp->data[lq]);
src/lib/16_vl.c:			//printf("\n%02d\n", bmp->offset);
src/lib/16_vl.c:			printf("a[aq]-aqpp=%02d\n", a[aq]-aqpp);
src/lib/16_vl.c:			//bmp->data[lq]=((bmp->data[lq]+bmp->offset)-a[aq]);
src/lib/16_vl.c://++++		  bmp->data[lq]=a[aq]-aqpp;
src/lib/16_vl.c://			  printf("_%d ", bmp->data[lq]);
src/lib/16_vl.c:			//if(lq > 0 && lq%bmp->width==0) printf("\n");
src/lib/16_vl.c:		else if(bmp->data[lq]+bmp->offset < ((*i)/3)-aqpp)
src/lib/16_vl.c:			if(bmp->data[lq]+bmp->offset >= aq)
src/lib/16_vl.c:				bmp->data[lq]=(bmp->data[lq]+bmp->offset)-aqpp;//-((z-(*i))/3);
src/lib/16_vl.c:				//printf("_%d ", bmp->data[lq]+bmp->offset)-aqpp-((z-(*i))/3);
src/lib/16_vl.c:			else bmp->data[lq]+=(bmp->offset-aqpp);
src/lib/16_vl.c:		//printf("%02d`", bmp->data[lq]);
src/lib/16_vl.c:		//if(lq > 0 && lq%bmp->width==0) printf("\n");
src/lib/16_vl.c:	//modexWaitBorder();	  /* waits one retrace -- less flicker */
src/lib/16_vl.c:	//modexWaitBorder();	  /* waits one retrace -- less flicker */
src/lib/16_vl.c://----			  if(pal[(*z)]==pal[(*z)+3] && pal[(*z)+1]==pal[(*z)+4] && pal[(*z)+2]==pal[(*z)+5])
src/lib/16_vl.c://0000				  (*z)-=3;
src/lib/16_vl.c://							  (*z)-=3;
src/lib/16_vl.c://							  (*i)-=3;
src/lib/16_vl.c://							  //printf("	  zv: %d  [%02d][%02d][%02d] wwww\n", (zz-z+q)/3, pal[(zz-z+q)], pal[(zz-z+q)+1], pal[(zz-z+q)+2]);
src/lib/16_vl.c://++++						  (*i)--;
src/lib/16_vl.c://							  (*z)--;
src/lib/16_vl.c:	word pageOff = (word) page->data;
src/lib/16_vl.c:	   significant bits of the x-coordinate: */
src/lib/16_vl.c:	VGA[(unsigned)((page->width/4) * y) + (x / 4) + pageOff] = color;
src/lib/16_vl.c:	word pageOff = (word) page->data;
src/lib/16_vl.c:	return VGA[(unsigned)((page->width/4) * y) + (x / 4) + pageOff];
src/lib/16_vl.c:			drawaddr += page->width >> 2;
src/lib/16_vl.c:	word addrq = (page->width/4) * y + (x / 4) + ((word)page->data);
src/lib/16_vl.c:		addrq += (page->width / 4) * 8;
src/lib/16_vl.c:	// NTS: It might even be faster to just let the modexDrawChar point directly at ROM font than to copy per char! --J.C.
src/lib/16_vl.c:"*/)/* || chw>=page->width*/)
src/lib/16_vl.c:// cls() - This clears the screen to the specified color, on the VGA or on //
src/lib/16_vl.c:	//modexClearRegion(page, 0, 0, page->width, page->height, color);
src/lib/16_vl.c:	_fmemset(Where, color, page->width*(page->height)/4);
src/lib/16_vl.c:	printf("video memory remaining: %u\n", v->vmem_remain);
src/lib/16_vl.c:	for(i=0; i<v->num_of_pages;i++)
src/lib/16_vl.c:		printf("(%Fp)", (v->page[i].data));
src/lib/16_vl.c:		printf(" size=%u	", v->page[i].pagesize);
src/lib/16_vl.c:		printf("w=%lu  h=%lu ", (unsigned long)v->page[i].width, (unsigned long)v->page[i].height);
src/lib/16_vl.c:		printf("sw=%lu  sh=%lu ", (unsigned long)v->page[i].sw, (unsigned long)v->page[i].sh);
src/lib/16_vl.c:		printf("pi=%u", v->page[i].pi);
src/lib/16_vl.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_vl.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_vl.h:/* -========================== Types & Macros ==========================- */
src/lib/16_vl.h:/* -======================= Constants & Vars ==========================- */
src/lib/16_vl.h:/* -============================ Functions =============================- */
src/lib/16_vl.h:	   significant bits of the x-coordinate: */
src/lib/16_vrs.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_vrs.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_vrs.c:	vrs_cont->data_size = size - sizeof(struct vrs_header);
src/lib/16_vrs.c:	vrs_cont->buffer = buffer;
src/lib/16_vrs.c:	vrl_id_iter = (uint16_t far *)(buffer + vrs_cont->vrs_hdr->offset_table[VRS_HEADER_OFFSET_SPRITE_ID_LIST]);
src/lib/16_vrs.c:	vrl_headers_offsets = (uint32_t far *)(buffer + vrs_cont->vrs_hdr->offset_table[VRS_HEADER_OFFSET_VRS_LIST]);
src/lib/16_vrs.c:		// Calc. vrl size as (next_offset - curr_offset)
src/lib/16_vrs.c:		if (i != num_of_vrl - 1){
src/lib/16_vrs.c:			vrl_size = vrl_headers_offsets[i+1] - vrl_headers_offsets[i] - sizeof(struct vrl1_vgax_header);
src/lib/16_vrs.c:		// If it's the last vrl, size is (next_vrs_struct_offset - curr_offset)
src/lib/16_vrs.c:			vrl_size = vrs_cont->vrs_hdr->offset_table[VRS_HEADER_OFFSET_SPRITE_ID_LIST] - vrl_headers_offsets[i] - sizeof(struct vrl1_vgax_header);
src/lib/16_vrs.c:	vrs_cont->vrl_line_offsets = vrl_line_offsets;
src/lib/16_vrs.c:	// If id is invalid, return -1
src/lib/16_vrs.c:		return -1;
src/lib/16_vrs.c:	ids = (uint16_t far*)(vrs_cont->buffer +
src/lib/16_vrs.c:		vrs_cont->vrs_hdr->offset_table[VRS_HEADER_OFFSET_SPRITE_ID_LIST]);
src/lib/16_vrs.c:	// Return -2 if we couldn't find the requested id
src/lib/16_vrs.c:		return -2;
src/lib/16_vrs.c:	vrl_offs_list = (uint32_t far *)(vrs_cont->buffer +
src/lib/16_vrs.c:					vrs_cont->vrs_hdr->offset_table[VRS_HEADER_OFFSET_VRS_LIST]);
src/lib/16_vrs.c:	vrl_cont->vrl_header = (struct vrl1_vgax_header far *)(vrs_cont->buffer + vrl_offs_list[counter]);
src/lib/16_vrs.c:	// Get .vrl size by integer arithmetics (next vrl offset - current vrl offset)
src/lib/16_vrs.c:		vrl_cont->data_size = vrl_offs_list[counter+1] - vrl_offs_list[counter] - sizeof(struct vrl1_vgax_header);
src/lib/16_vrs.c:	// If we are retriving the last vrl, size is ids_list offset - current vrl offset, as next vrl offs is 0
src/lib/16_vrs.c:		vrl_cont->data_size = vrs_cont->vrs_hdr->offset_table[VRS_HEADER_OFFSET_SPRITE_ID_LIST] - vrl_offs_list[counter] - sizeof(struct vrl1_vgax_header);
src/lib/16_vrs.c:	vrl_cont->line_offsets = vrs_cont->vrl_line_offsets[counter];
src/lib/16_vrs.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/16_vrs.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/16_vrs.h:* + char *filename - name of the file to load
src/lib/16_vrs.h:* + struct vrs_container *vrs_cont - pointer to the vrs_container
src/lib/16_vrs.h:* + int - 0 on succes, 1 on failure
src/lib/16_vrs.h:* + struct vrs_container *vrs_cont - pointer to the vrs_container
src/lib/16_vrs.h:* + uint16_t id - id of the vrl to retrive
src/lib/16_vrs.h:* + struct vrl_container * vrl_cont - pointer to vrl_container to load to
src/lib/16_vrs.h:* int - operation status
src/lib/bakapee.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/bakapee.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/bakapee.c:	//if(pee->coor < 256)
src/lib/bakapee.c:		modexcls(page, pee->coor, VGA);
src/lib/bakapee.c:		pee->coor++;
src/lib/bakapee.c:	//}else pee->coor = 0;
src/lib/bakapee.c:	if(pee->coor <= HGQ)
src/lib/bakapee.c:		modexcls(page, pee->coor, VGA);
src/lib/bakapee.c:		pee->coor++;
src/lib/bakapee.c:	}else pee->coor = LGQ;
src/lib/bakapee.c:	if(pee->sy < page->sh+1)
src/lib/bakapee.c:		if(pee->sx < page->sw+1)
src/lib/bakapee.c:			//printf("%d %d %d %d\n", pee->sx, pee->sy, svq, pee->coor);
src/lib/bakapee.c:			pee->sx++;
src/lib/bakapee.c:		}else pee->sx = 0;
src/lib/bakapee.c:		if(pee->sx == page->sw)
src/lib/bakapee.c:			pee->sy++;
src/lib/bakapee.c:			if(svq == 7) pee->coor++;
src/lib/bakapee.c:			if(pee->sy == page->sh && svq == 8) pee->coor = rand()%256;
src/lib/bakapee.c:	}else pee->sy = 0;
src/lib/bakapee.c:	if(pee->tile)
src/lib/bakapee.c:	//fill_block(pee->xx, pee->yy, pee->xx+TILEWH, pee->yy+TILEWH, pee->coor);
src/lib/bakapee.c:		mxFillBox(pee->xx, pee->yy, TILEWH, TILEWH, pee->coor, OP_SET);
src/lib/bakapee.c:		modexClearRegion(page, pee->xx, pee->yy, TILEWH, TILEWH, pee->coor);
src/lib/bakapee.c:		modexputPixel(page, pee->xx, pee->yy, pee->coor);
src/lib/bakapee.c:	if(pee->tile)
src/lib/bakapee.c:		if(pee->xx<0) pee->xx=(page->sw-TILEWH);
src/lib/bakapee.c:		if(pee->yy<0) pee->yy=(page->sh-TILEWH);
src/lib/bakapee.c:		if(pee->xx>(page->sw-TILEWH)) pee->xx=0;
src/lib/bakapee.c:		if(pee->yy>(page->sh-TILEWH)/*+(TILEWH*BUFFMX)*/) pee->yy=0;
src/lib/bakapee.c:		if(pee->xx<0) pee->xx=page->sw;
src/lib/bakapee.c:		if(pee->yy<0) pee->yy=page->sh;
src/lib/bakapee.c:		if(pee->xx>page->sw) pee->xx=0;
src/lib/bakapee.c:		if(pee->yy>page->sh) pee->yy=0;
src/lib/bakapee.c:	if(pee->gq == BONK) dingu(pee);
src/lib/bakapee.c:	if(!pee->bakax)
src/lib/bakapee.c:		if(pee->tile)
src/lib/bakapee.c:		pee->xx-=TILEWH;
src/lib/bakapee.c:		else pee->xx--;
src/lib/bakapee.c:	else if(pee->bakax>1)
src/lib/bakapee.c:		if(pee->tile)
src/lib/bakapee.c:		pee->xx+=TILEWH;
src/lib/bakapee.c:		else pee->xx++;
src/lib/bakapee.c:	if(!pee->bakay)
src/lib/bakapee.c:		if(pee->tile)
src/lib/bakapee.c:		pee->yy-=TILEWH;
src/lib/bakapee.c:		else pee->yy--;
src/lib/bakapee.c:	else if(pee->bakay>1)
src/lib/bakapee.c:		if(pee->tile)
src/lib/bakapee.c:		pee->yy+=TILEWH;
src/lib/bakapee.c:		else pee->yy++;
src/lib/bakapee.c:	if(pee->coor < HGQ && pee->coor < LGQ) pee->coor = LGQ;
src/lib/bakapee.c:	if(pee->coor < HGQ)
src/lib/bakapee.c:		pee->coor++;
src/lib/bakapee.c:		pee->coor = LGQ;
src/lib/bakapee.c:	if(pee->gq<BONK)
src/lib/bakapee.c:		pee->gq++;
src/lib/bakapee.c:		pee->gq = 0;
src/lib/bakapee.c:	pee->bakax = rand()%3; pee->bakay = rand()%3;
src/lib/bakapee.c:/*-----------ding-------------*/
src/lib/bakapee.c://++++  if(q <= 4 && q!=2 && gq == BONK-1) coor = rand()%HGQ;
src/lib/bakapee.c:			if(pee->xx==page->sw){pee->bakax=0;}
src/lib/bakapee.c:			if(pee->xx==0){pee->bakax=1;}
src/lib/bakapee.c:			if(pee->yy==page->sh){pee->bakay=0;}
src/lib/bakapee.c:			if(pee->yy==0){pee->bakay=1;}
src/lib/bakapee.c:			if(pee->tile)
src/lib/bakapee.c:			modexClearRegion(page, (rand()*TILEWH)%page->width, (rand()*TILEWH)%(page->height), TILEWH, TILEWH, 0);
src/lib/bakapee.c:			modexputPixel(page, rand()%page->width, rand()%page->height, 0);
src/lib/bakapee.c:			if(pee->xx!=page->sw||pee->yy!=page->sh)
src/lib/bakapee.c:				if(pee->xx==0){pee->bakax=1;pee->bakay=-1;d3y=1;}
src/lib/bakapee.c:				if(pee->yy==0){pee->bakax=1;pee->bakay=0;d3y=1;}
src/lib/bakapee.c:				if(pee->xx==page->sw){pee->bakax=-1;pee->bakay=-1;d3y=1;}
src/lib/bakapee.c:				if(pee->yy==page->sh){pee->bakax=1;pee->bakay=0;d3y=1;}
src/lib/bakapee.c:			}else if(pee->xx==page->sw&&pee->yy==page->sh) pee->xx=pee->yy=0;
src/lib/bakapee.c:				if(pee->bakay<0)
src/lib/bakapee.c:					pee->yy--;
src/lib/bakapee.c:					d3y--;
src/lib/bakapee.c:				if(pee->bakay>0)
src/lib/bakapee.c:					pee->yy++;
src/lib/bakapee.c:					d3y--;
src/lib/bakapee.c:			if(pee->bakax<0)
src/lib/bakapee.c:				pee->xx--;
src/lib/bakapee.c:			if(pee->bakax>0)
src/lib/bakapee.c:				pee->xx++;
src/lib/bakapee.c:			pee->coor = rand()%256;
src/lib/bakapee.c:			modexcls(page, pee->coor, VGA);
src/lib/bakapee.c:			if(pee->coor <= HGQ)
src/lib/bakapee.c:				pee->coor++;
src/lib/bakapee.c:			}else pee->coor = LGQ;
src/lib/bakapee.c:			modexprint(page, page->sw/2, page->sh/2, 1, 47, 0, "bakapi");
src/lib/bakapee.c:			if(pee->coor <= HGQ)
src/lib/bakapee.c:				pee->coor++;
src/lib/bakapee.c:			}else pee->coor = LGQ;
src/lib/bakapee.c:			ssd(page, pee, q); /*printf("%d\n", pee->coor);*/
src/lib/bakapee.c:			if(!pee->bakax){ pee->xx--;}
src/lib/bakapee.c:			else if(pee->bakax>0){ pee->xx++; }
src/lib/bakapee.c:			if(!pee->bakay){ pee->yy--;}
src/lib/bakapee.c:			else if(pee->bakay>0){ pee->yy++; }
src/lib/bakapee.c:			tx+=pee->xx+TILEWH+4;
src/lib/bakapee.c:			ty+=pee->yy+TILEWH+4;
src/lib/bakapee.c:			modexClearRegion(page, tx, ty, 4, 4, pee->coor);
src/lib/bakapee.c:			if(pee->tile)
src/lib/bakapee.c:			modexClearRegion(page, (rand()*4)%page->width, (rand()*4)%(page->height), 4, 4, 0);
src/lib/bakapee.c:			modexputPixel(page, rand()%page->width, rand()%(page->height), 0);
src/lib/bakapee.c:			//printf("%d %d %d %d %d %d\n", pee->xx, pee->yy, tx, ty, TILEWH);
src/lib/bakapee.c:	//pee->coor++;
src/lib/bakapee.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123
src/lib/bakapee.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/bakapee.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/bakapee.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/bitmap.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/bitmap.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/bitmap.c:	result->width = head.xmax - head.xmin + 1;
src/lib/bitmap.c:	result->height = head.ymax - head.ymin + 1;
src/lib/bitmap.c:		exit(-2);
src/lib/bitmap.c:	fseek(file, -769, SEEK_END);
src/lib/bitmap.c:	result->palette = modexNewPal();
src/lib/bitmap.c:		result->palette[index] = val >> 2;
src/lib/bitmap.c:		result->palette[index]  = head.pal16[index];
src/lib/bitmap.c:		exit(-2);
src/lib/bitmap.c:		exit(-1);
src/lib/bitmap.c:	for(; count && index < bufSize; count--,index++)  {
src/lib/bitmap.c:		exit(-2);
src/lib/bitmap.c:		ts.data[i] = ts.data[i-1] + twidth * theight;
src/lib/bitmap.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/bitmap.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/ems.c:may be used within commercial and non-commercial applications without
src/lib/ems.c:        or -1 if an error occurs.
src/lib/ems.c:          return -1;
src/lib/ems.c:          assigned to the pages or -1 if there is an error
src/lib/ems.c:               return -1;
src/lib/ems.c:          while(n-- > 0)
src/lib/ems.c:          while(n-- > 0)
src/lib/ems.h:may be used within commercial and non-commercial applications without
src/lib/midi.c: * (C) 2010-2012 Jonathan Campbell.
src/lib/midi.c: *   - MS-DOS [pure DOS mode, or Windows or OS/2 DOS Box]
src/lib/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/lib/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence) {
src/lib/midi.c:		t->eof = 1;
src/lib/midi.c:	c = *(t->read);
src/lib/midi.c:	if (FP_OFF(t->read) >= 0xF) /* 16:16 far pointer aware (NTS: Programs reassigning this pointer MUST normalize the FAR pointer) */
src/lib/midi.c:		t->read = MK_FP(FP_SEG(t->read)+0x1,0);
src/lib/midi.c:		t->read++;
src/lib/midi.c:	t->read++;
src/lib/midi.c:	t->wait = ~0UL;
src/lib/midi.c:	t->read = t->fence;
src/lib/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/lib/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence)
src/lib/midi.c:		tt = farptr2phys(t->read);
src/lib/midi.c:		rem = farptr2phys(t->fence) - tt;
src/lib/midi.c:		t->read = MK_FP(tt>>4,tt&0xF);
src/lib/midi.c:	rem = (unsigned long)(t->fence - t->read);
src/lib/midi.c:	t->read += len;
src/lib/midi.c:	unsigned int tch = (unsigned int)(t - midi_trk); /* pointer math */
src/lib/midi.c:	unsigned int ach = (unsigned int)(ch - midi_ch); /* pointer math */
src/lib/midi.c:	unsigned int ach = (unsigned int)(ch - midi_ch); /* pointer math */
src/lib/midi.c:	note->busy = 1;
src/lib/midi.c:	note->note_number = key;
src/lib/midi.c:	note->note_velocity = vel;
src/lib/midi.c:	note->note_track = (unsigned int)(t - midi_trk);
src/lib/midi.c:	note->note_channel = (unsigned int)(ch - midi_ch);
src/lib/midi.c:	ach = (unsigned int)(note - midi_notes); /* which FM channel? */
src/lib/midi.c:	adlib_fm[ach].mod.attack_rate = vel >> 3; /* 0-127 to 0-15 */
src/lib/midi.c:	if ((ch->program >= 8 && ch->program <= 15)/*Chromatic percussion*/ ||
src/lib/midi.c:		(ch->program >= 112 && ch->program <= 119)/*Percussive*/ ||
src/lib/midi.c:		ch == &midi_ch[9]/*MIDI channel 10 (DAMN YOU 1-BASED COUNTING)*/)
src/lib/midi.c:	note->busy = 1;
src/lib/midi.c:	note->note_number = key;
src/lib/midi.c:	note->note_velocity = vel;
src/lib/midi.c:	note->note_track = (unsigned int)(t - midi_trk);
src/lib/midi.c:	note->note_channel = (unsigned int)(ch - midi_ch);
src/lib/midi.c:	ach = (unsigned int)(note - midi_notes); /* which FM channel? */
src/lib/midi.c:	adlib_fm[ach].mod.attack_rate = vel >> 3; /* 0-127 to 0-15 */
src/lib/midi.c:	note->busy = 0;
src/lib/midi.c:	ach = (unsigned int)(note - midi_notes); /* which FM channel? */
src/lib/midi.c:	adlib_fm[ach].mod.attack_rate = vel >> 3; /* 0-127 to 0-15 */
src/lib/midi.c:	ch->program = inst;
src/lib/midi.c:static inline void on_pitch_bend(struct midi_track *t,struct midi_channel *ch,int bend/*-8192 to 8192*/) {
src/lib/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/lib/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence)
src/lib/midi.c:	/* NTS: 16-bit large/compact builds MUST compare pointers as unsigned long to compare FAR pointers correctly! */
src/lib/midi.c:	if (t->read == NULL || (unsigned long)t->read >= (unsigned long)t->fence) {
src/lib/midi.c:		t->eof = 1;
src/lib/midi.c:	t->us_tick_cnt_mtpq += 10000UL * (unsigned long)ticks_per_quarter_note;
src/lib/midi.c:	while (t->us_tick_cnt_mtpq >= t->us_per_quarter_note) {
src/lib/midi.c:		t->us_tick_cnt_mtpq -= t->us_per_quarter_note;
src/lib/midi.c:		while (t->wait == 0) {
src/lib/midi.c:			if ((unsigned long)t->read >= (unsigned long)t->fence) {
src/lib/midi.c:				t->eof = 1;
src/lib/midi.c:						t->last_status = 0;
src/lib/midi.c:						t->last_status = b;
src/lib/midi.c:				b = t->last_status;
src/lib/midi.c:					on_pitch_bend(t,ch,((c&0x7F)|((d&0x7F)<<7))-8192); /* c=LSB d=MSB */
src/lib/midi.c:							fprintf(stderr,"Type 0x7F len=%lu %p/%p/%p\n",len,t->raw,t->read,t->fence);
src/lib/midi.c:								d -= 3;
src/lib/midi.c:								t->us_per_quarter_note = ((unsigned long)midi_trk_read(t)<<16UL)+
src/lib/midi.c:											t->us_per_quarter_note;
src/lib/midi.c:								fprintf(stderr,"Type 0x%02x len=%lu %p/%p/%p\n",c,d,t->raw,t->read,t->fence);
src/lib/midi.c:							fprintf(stderr,"t=%u Unknown MIDI f message 0x%02x 0x%02x %p/%p/%p\n",i,b,c,t->raw,t->read,t->fence);
src/lib/midi.c:						fprintf(stderr,"Sysex len=%lu %p/%p/%p\n",len,t->raw,t->read,t->fence);
src/lib/midi.c:						fprintf(stderr,"t=%u Unknown MIDI message 0x%02x at %p/%p/%p\n",i,b,t->raw,t->read,t->fence);
src/lib/midi.c:			t->wait = midi_trk_read_delta(t);
src/lib/midi.c:		if (t->wait != 0) {
src/lib/midi.c:			t->wait--;
src/lib/midi.c:/* WARNING: subroutine call in interrupt handler. make sure you compile with -zu flag for large/compact memory models */
src/lib/midi.c:		irq0_cnt -= irq0_max;
src/lib/midi.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/lib/midi.c:		f->ch_a = f->ch_b = f->ch_c = f->ch_d = 1;
src/lib/midi.c:		f->mod_multiple = 1;
src/lib/midi.c:		f->total_level = 63 - 16;
src/lib/midi.c:		f->attack_rate = 15;
src/lib/midi.c:		f->decay_rate = 4;
src/lib/midi.c:		f->sustain_level = 0;
src/lib/midi.c:		f->release_rate = 8;
src/lib/midi.c:		f->f_number = 400;
src/lib/midi.c:		f->sustain = 1;
src/lib/midi.c:		f->octave = 4;
src/lib/midi.c:		f->key_on = 0;
src/lib/midi.c:		f->mod_multiple = 1;
src/lib/midi.c:		f->total_level = 63 - 16;
src/lib/midi.c:		f->attack_rate = 15;
src/lib/midi.c:		f->decay_rate = 4;
src/lib/midi.c:		f->sustain_level = 0;
src/lib/midi.c:		f->release_rate = 8;
src/lib/midi.c:		f->f_number = 0;
src/lib/midi.c:		f->sustain = 1;
src/lib/midi.c:		f->octave = 0;
src/lib/midi.c:		f->key_on = 0;
src/lib/midi.c:	t->eof = 0;
src/lib/midi.c:	t->last_status = 0;
src/lib/midi.c:	t->us_tick_cnt_mtpq = 0;
src/lib/midi.c:	t->us_per_quarter_note = (60000000UL / 120UL); /* 120BPM */
src/lib/midi.c:	t->read = midi_trk[i].raw;
src/lib/midi.c:	t->wait = midi_trk_read_delta(t); /* and then the read pointer will point at the MIDI event when wait counts down */
src/lib/midi.c:			/* byte 0-1 = format type (0,1 or 2) */
src/lib/midi.c:			/* byte 2-3 = number of tracks */
src/lib/midi.c:			/* byte 4-5 = time divison */
src/lib/midi.c:					cando = 0x10000UL - (unsigned long)FP_OFF(p);
src/lib/midi.c:					if (cando > 0xFFFFUL) cando = 0xFFFFUL; /* we're limited to 64KB-1 of reading */
src/lib/midi.c:					rem -= cando;
src/lib/midi.h: * (C) 2010-2012 Jonathan Campbell.
src/lib/midi.h: *   - MS-DOS [pure DOS mode, or Windows or OS/2 DOS Box]
src/lib/scroll16.c: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/scroll16.c: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/scroll16.c:			//0000pip[0].video->startclk = (*clockw);
src/lib/scroll16.c:			//printf("pip[0].page->tilesw=%d	", pip[0].page->tilesw); printf("pip[0].page->tw=%d\n", pip[0].page->tw);
src/lib/scroll16.c:			if(pip[0].tx >= 0 && pip[0].tx+pip[0].page->tw < pip[0].map->width && player[pn].tx == pip[0].tx+pip[0].page->tilemidposscreenx &&
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx+1 == TRIGGX && player[pn].ty == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//mapScrollRight(pip, player, !(pip[0].video->p), pn);
src/lib/scroll16.c:					mapScrollRight(pip, player, (pip[0].video->p), pn);
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:			else if(player[pn].tx < pip[0].map->width && !(pip[0].map->data[(player[pn].tx)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx+1 == TRIGGX && player[pn].ty == TRIGGY))
src/lib/scroll16.c:				if(!pageflipflop) modexCopyPageRegion(pip[1].page, pip[0].page, player[pn].x, player[pn].y-TILEWH, player[pn].x, player[pn].y-TILEWH, 24, 32);
src/lib/scroll16.c:				PBUFSFUN(pip[0].page, player[pn].x, player[pn].y-TILEWH, 24, 32, 24, 32, PLAYERBMPDATA);
src/lib/scroll16.c:				modexClearRegion(pip[1].page, player[pn].x, player[pn].y-TILEWH, 24, 32, 14);
src/lib/scroll16.c:			if(pip[0].tx > 0 && pip[0].tx+pip[0].page->tw <= pip[0].map->width && player[pn].tx == pip[0].tx+pip[0].page->tilemidposscreenx &&
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx-2)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx-1 == TRIGGX && player[pn].ty == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//mapScrollLeft(pip, player, !(pip[0].video->p), pn);
src/lib/scroll16.c:					mapScrollLeft(pip, player, (pip[0].video->p), pn);
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; player[pn].tx--; }
src/lib/scroll16.c:			else if(player[pn].tx > 1 && !(pip[0].map->data[(player[pn].tx-2)+(pip[0].map->width*(player[pn].ty-1))] == 0))//!(player[pn].tx-1 == TRIGGX && player[pn].ty == TRIGGY))
src/lib/scroll16.c:					player[pn].x-=(player[pn].speed);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; player[pn].tx--; }
src/lib/scroll16.c:				if(!pageflipflop) modexCopyPageRegion(pip[1].page, pip[0].page, player[pn].x, player[pn].y-TILEWH, player[pn].x, player[pn].y-TILEWH, 24, 32);
src/lib/scroll16.c:				PBUFSFUN(pip[0].page, player[pn].x, player[pn].y-TILEWH, 24, 96, 24, 32, PLAYERBMPDATA);
src/lib/scroll16.c:				modexClearRegion(pip[1].page, player[pn].x, player[pn].y-TILEWH, 24, 32, 10);
src/lib/scroll16.c:			player[pn].triggerx = player[pn].tx-1;
src/lib/scroll16.c:			if(pip[0].ty >= 0 && pip[0].ty+pip[0].page->th < pip[0].map->height && player[pn].ty == pip[0].ty+pip[0].page->tilemidposscreeny &&
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty))] == 0))//!(player[pn].tx == TRIGGX && player[pn].ty+1 == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//mapScrollDown(pip, player, !(pip[0].video->p), pn);
src/lib/scroll16.c:					mapScrollDown(pip, player, (pip[0].video->p), pn);
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:			else if(player[pn].ty < pip[0].map->height && !(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty))] == 0))//!(player[pn].tx == TRIGGX && player[pn].ty+1 == TRIGGY))
src/lib/scroll16.c:				if(!pageflipflop) modexCopyPageRegion(pip[1].page, pip[0].page, player[pn].x, player[pn].y-TILEWH, player[pn].x, player[pn].y-TILEWH, 24, 32);
src/lib/scroll16.c:				PBUFSFUN(pip[0].page, player[pn].x, player[pn].y-TILEWH, 24, 64, 24, 32, PLAYERBMPDATA);
src/lib/scroll16.c:				modexClearRegion(pip[1].page, player[pn].x, player[pn].y-TILEWH, 24, 32, 9);
src/lib/scroll16.c:			if(pip[0].ty > 0 && pip[0].ty+pip[0].page->th <= pip[0].map->height && player[pn].ty == pip[0].ty+pip[0].page->tilemidposscreeny &&
src/lib/scroll16.c:			!(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty-2))] == 0))//!(player[pn].tx == TRIGGX && player[pn].ty-1 == TRIGGY))	//collision detection!
src/lib/scroll16.c:					//mapScrollUp(pip, player, !(pip[0].video->p), pn);
src/lib/scroll16.c:					mapScrollUp(pip, player, (pip[0].video->p), pn);
src/lib/scroll16.c:					//0000pip[0].video->clk = ((*clockw)-pip[0].video->startclk)/18.2;
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; player[pn].ty--; }
src/lib/scroll16.c:			else if(player[pn].ty > 1 && !(pip[0].map->data[(player[pn].tx-1)+(pip[0].map->width*(player[pn].ty-2))] == 0))//!(player[pn].tx == TRIGGX &&  player[pn].ty-1 == TRIGGY))
src/lib/scroll16.c:					player[pn].y-=(player[pn].speed);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; player[pn].ty--; }
src/lib/scroll16.c:				if(!pageflipflop) modexCopyPageRegion(pip[1].page, pip[0].page, player[pn].x, player[pn].y-TILEWH, player[pn].x, player[pn].y-TILEWH, 24, 32);
src/lib/scroll16.c:				PBUFSFUN(pip[0].page, player[pn].x, player[pn].y-TILEWH, 24, 0, 24, 32, PLAYERBMPDATA);
src/lib/scroll16.c:				modexClearRegion(pip[1].page, player[pn].x, player[pn].y-TILEWH, 24, 32, 12);
src/lib/scroll16.c:			player[pn].triggery = player[pn].ty-1;
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].tx >= 0 && pip[pip[0].pan->pn].tx+pip[pip[0].pan->pn].page->tw < pip[pip[0].pan->pn].page->tilesw)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dx+=4;
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].tx++; }
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].tx > 0 && pip[pip[0].pan->pn].tx+pip[pip[0].pan->pn].page->tw <= pip[pip[0].pan->pn].page->tilesw)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dx-=4;
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].tx--; }
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].ty >= 0 && pip[pip[0].pan->pn].ty+pip[pip[0].pan->pn].page->th < pip[pip[0].pan->pn].page->tilesh)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dy+=4;
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].ty++; }
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].ty > 0 && pip[pip[0].pan->pn].ty+pip[pip[0].pan->pn].page->th <= pip[pip[0].pan->pn].page->tilesh)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dy-=4;
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].ty--; }
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].tx >= 0 && pip[pip[0].pan->pn].tx+pip[pip[0].pan->pn].page->tw < pip[pip[0].pan->pn].page->tilesw)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dx+=4;
src/lib/scroll16.c:					//modexShowPageVsync(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].tx++; }
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].tx > 0 && pip[pip[0].pan->pn].tx+pip[pip[0].pan->pn].page->tw <= pip[pip[0].pan->pn].page->tilesw)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dx-=4;
src/lib/scroll16.c:					//modexShowPageVsync(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].tx--; }
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].ty >= 0 && pip[pip[0].pan->pn].ty+pip[pip[0].pan->pn].page->th < pip[pip[0].pan->pn].page->tilesh)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dy+=4;
src/lib/scroll16.c:					//modexShowPageVsync(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].ty++; }
src/lib/scroll16.c:			if(pip[pip[0].pan->pn].ty > 0 && pip[pip[0].pan->pn].ty+pip[pip[0].pan->pn].page->th <= pip[pip[0].pan->pn].page->tilesh)
src/lib/scroll16.c:					pip[pip[0].pan->pn].page[0].dy-=4;
src/lib/scroll16.c:					//modexShowPageVsync(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:					modexShowPage(pip[pip[0].pan->pn].page);
src/lib/scroll16.c:				} else { player[pn].q = 1; player[pn].d = 2; pip[pip[0].pan->pn].ty--; }
src/lib/scroll16.c:	pip[0].page = &gv->video.page[0];
src/lib/scroll16.c:	pip[0].video = &gv->video;
src/lib/scroll16.c:	for(i=1;i<gv->video.num_of_pages;i++)
src/lib/scroll16.c:		pip[i].page	=	&gv->video.page[i];
src/lib/scroll16.c://		map->tiles = malloc(sizeof(tiles_t));
src/lib/scroll16.c:	//	map->tiles = (tiles_t *)alloc_emem(sizeof(tiles_t));
src/lib/scroll16.c://		map->tiles->data = malloc(sizeof(bitmap_t));
src/lib/scroll16.c:	//	map->tiles->data = (bitmap_t *)alloc_emem(sizeof(bitmap_t));
src/lib/scroll16.c://	map->tiles->data->width = (TILEWH);
src/lib/scroll16.c://	map->tiles->data->height= TILEWH;
src/lib/scroll16.c://		map->tiles->data->data = malloc((TILEWH*2)*TILEWH);
src/lib/scroll16.c:	//	map->tiles->data->data = (byte *)alloc_emem((TILEWH*2)*TILEWH);
src/lib/scroll16.c://	map->tiles->tileHeight = TILEWH;
src/lib/scroll16.c://	map->tiles->tileWidth =TILEWH;
src/lib/scroll16.c://	map->tiles->rows = 1;
src/lib/scroll16.c://	map->tiles->cols = 1;//2;
src/lib/scroll16.c:	//for(y=0; y<map->height; y++) {
src/lib/scroll16.c:	//for(x=0; x<map->width; x++) {
src/lib/scroll16.c:		  map->tiles->data->data[i+1] = map->data[q];//28;//0x24;
src/lib/scroll16.c://		  printf("[%d]", map->tiles->data->data[i]);
src/lib/scroll16.c:		  //map->tiles->data->data[i] = map->data[q];//0;//0x34;
src/lib/scroll16.c:		  //printf("]%d[==[%d]", i, map->tiles->data->data[i]);
src/lib/scroll16.c://	printf("[%d]", map->data[q]);
src/lib/scroll16.c:	for(y=0; y<map->height; y++) {
src/lib/scroll16.c:		for(x=0; x<map->width; x++) {
src/lib/scroll16.c://			map->data[i]=255;
src/lib/scroll16.c:			printf("[%d]", map->data[i]);
src/lib/scroll16.c:	mv[id].page->data += 4;
src/lib/scroll16.c:	mv[id].page[0].dx = mv[id].map->tiles->tileWidth;
src/lib/scroll16.c:	x= mv[0].page->sw + mv[id].map->tiles->tileWidth;
src/lib/scroll16.c:			mapDrawCol(&mv[0], mv[0].tx + mv[0].page->tw, mv[0].ty-1, x, player, mv->page[0].dx);
src/lib/scroll16.c:				modexCopyPageRegion(mv[id].page, mv[0].page, x, 0, x, 0, mv[id].map->tiles->tileWidth, mv[id].map->tiles->tileHeight*(mv[0].page->th+2));
src/lib/scroll16.c:	mv[0].video->r=1;
src/lib/scroll16.c:	mv[id].page[0].dx -= player[plid].speed;
src/lib/scroll16.c:	mv[id].tx--;
src/lib/scroll16.c:	mv[id].page->data -= 4;
src/lib/scroll16.c:	mv[id].page[0].dx = mv[id].map->tiles->tileWidth;
src/lib/scroll16.c:			mapDrawCol(&mv[0], mv[0].tx - 1, mv[0].ty-1, x, player, mv->page[0].dx);
src/lib/scroll16.c:				modexCopyPageRegion(mv[id].page, mv[0].page, x, 0, x, 0, mv[id].map->tiles->tileWidth, mv[id].map->tiles->tileHeight*(mv[0].page->th+2));
src/lib/scroll16.c:	mv[0].video->r=1;
src/lib/scroll16.c:	mv[id].page[0].dy -= player[plid].speed;
src/lib/scroll16.c:	mv[id].ty--;
src/lib/scroll16.c:	mv[id].page->data -= mv[id].page->pi;
src/lib/scroll16.c:	mv[id].page[0].dy = mv[id].map->tiles->tileHeight;
src/lib/scroll16.c:			mapDrawRow(&mv[0], mv[0].tx - 1, mv[0].ty-1, y, player, mv->page[0].dy);
src/lib/scroll16.c:				modexCopyPageRegion(mv[id].page, mv[0].page, 0, y, 0, y, mv[id].map->tiles->tileWidth*(mv[0].page->tw+2), mv[id].map->tiles->tileHeight);
src/lib/scroll16.c:	mv[0].video->r=1;
src/lib/scroll16.c:	mv[id].page->data += mv[id].page->pi;
src/lib/scroll16.c:	mv[id].page[0].dy = mv[id].map->tiles->tileHeight;
src/lib/scroll16.c:	y= mv[0].page->sh + mv[id].map->tiles->tileHeight;
src/lib/scroll16.c:			mapDrawRow(&mv[0], mv[0].tx - 1, mv[0].ty+mv[0].page->th, y, player, mv->page[0].dy);
src/lib/scroll16.c:				modexCopyPageRegion(mv[id].page, mv[0].page, 0, y, 0, y, mv[id].map->tiles->tileWidth*(mv[0].page->tw+2), mv[id].map->tiles->tileHeight);
src/lib/scroll16.c:	mv[0].video->r=1;
src/lib/scroll16.c:	mv[id].page->dx += player[plid].speed;
src/lib/scroll16.c:	if(mv[id].page->dx >= mv[0].dxThresh )
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data+4, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:		mv[id].page->data += 4;
src/lib/scroll16.c:		mv[id].page->dx = mv[0].map->tiles->tileWidth;
src/lib/scroll16.c:	mv[id].page->dx -= player[plid].speed;
src/lib/scroll16.c:	if(mv[id].page->dx == 0)
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data-4, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:		mv[id].page->data -= 4;
src/lib/scroll16.c:		mv[id].page->dx = mv[0].map->tiles->tileWidth;
src/lib/scroll16.c:	mv[id].page->dy -= player[plid].speed;
src/lib/scroll16.c:	if(mv[id].page->dy == 0)
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data-mv[id].page->pi, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:		mv[id].page->data -= mv[id].page->pi;
src/lib/scroll16.c:		mv[id].page->dy = mv[0].map->tiles->tileWidth;
src/lib/scroll16.c:	mv[id].page->dy += player[plid].speed;
src/lib/scroll16.c:	if(mv[id].page->dy >= mv[0].dxThresh )
src/lib/scroll16.c:// 		_fmemmove(mv[id].page->data+mv[id].page->pi, mv[id].page->data, mv[id].page->pagesize);
src/lib/scroll16.c:		mv[id].page->data += mv[id].page->pi;
src/lib/scroll16.c:		mv[id].page->dy = mv[0].map->tiles->tileWidth;
src/lib/scroll16.c:	player[pn].tx = x + pip[0].tx + pip[0].page->tilemidposscreenx;
src/lib/scroll16.c:	player[pn].ty = y + pip[0].ty + pip[0].page->tilemidposscreeny;
src/lib/scroll16.c:	if((map->width == map->height == 0) && (q>0))
src/lib/scroll16.c:		map->width=MAPW;///2;
src/lib/scroll16.c:		map->height=MAPH;///2;
src/lib/scroll16.c://		map->data = malloc(((map->width*map->height)+1)*sizeof(byte));
src/lib/scroll16.c:		map->data = &x;
src/lib/scroll16.c:		map->tiles = malloc(sizeof(tiles_t));
src/lib/scroll16.c://		map->tiles->data = &bp;
src/lib/scroll16.c:		dbg_mapdata = map->data;
src/lib/scroll16.c:		map->tiles->tileHeight = 16;
src/lib/scroll16.c:		map->tiles->tileWidth = 16;
src/lib/scroll16.c:		map->tiles->rows = 1;
src/lib/scroll16.c:		map->tiles->cols = 1;
src/lib/scroll16.c:	modexClearRegion(mv[0].page, 0, 0, mv[0].page->width, mv[0].page->height, 0);
src/lib/scroll16.c:	i=mv[0].ty * mv[0].map->width + mv[0].tx;
src/lib/scroll16.c:	for(ty=mv[0].ty-1; py < mv[0].page->sh+mv->dyThresh && ty < mv[0].map->height; ty++, py+=mv[0].map->tiles->tileHeight) {
src/lib/scroll16.c:		mapDrawWRow(&mv[0], tx-1, ty, py);
src/lib/scroll16.c:	i+=mv->map->width - tx;
src/lib/scroll16.c:	if(!pageploop) modexCopyPageRegion(mv[1].page, mv[0].page, 0, 0, 0, 0, mv[0].page->width, mv[0].page->height);
src/lib/scroll16.c:// 				for (j=0;j < (mv[0].page->height)+(mv[1].page->height)+(mv[2].page->height)+(mv[3].page->height);j++,o += vga_state.vga_stride)
src/lib/scroll16.c:	mv[0].page->dx = mv[1].page->dx = mv[2].page->dx = mv[3].page->dx = mv->map->tiles->tileWidth;
src/lib/scroll16.c:	mv[0].page->dy = mv[1].page->dy = mv[2].page->dy = mv[3].page->dy = mv->map->tiles->tileHeight;
src/lib/scroll16.c:	mv[0].dxThresh = mv[1].dxThresh = mv[2].dxThresh = mv[3].dxThresh = mv->map->tiles->tileWidth * 2;
src/lib/scroll16.c:	mv[0].dyThresh = mv[1].dyThresh = mv[2].dxThresh = mv[3].dxThresh = mv->map->tiles->tileHeight * 2;
src/lib/scroll16.c:		modexClearRegion(page, x, y, t->tileWidth, t->tileHeight, 0); //currently the over scan color!
src/lib/scroll16.c:		rx = (((i-1) % ((t->data->width)/t->tileWidth)) * t->tileWidth);
src/lib/scroll16.c:		ry = (((i-1) / ((t->data->height)/t->tileHeight)) * t->tileHeight);
src/lib/scroll16.c:				modexClearRegion(page, x, y, t->tileWidth, t->tileHeight, ((dbg_mapdata[i])+1));
src/lib/scroll16.c:				//modexprint(page, x, y, 1, 15, 0, (char const *)(t->debug_data[i]));
src/lib/scroll16.c:				PBUFBFUN		(page, x, y, rx, ry, t->tileWidth, t->tileHeight, (t->data));
src/lib/scroll16.c:				//draw_vrl1_vgax_modex(x-rx,y-ry,vrl_header,vrl_lineoffs,buffer+sizeof(*vrl_header),bufsz-sizeof(*vrl_header));
src/lib/scroll16.c:				//modexDrawBmpRegion	(page, x, y, rx, ry, t->tileWidth, t->tileHeight, (t->data));
src/lib/scroll16.c:				modexClearRegion(page, x, y, t->tileWidth, t->tileHeight, (dbg_mapdata[i])+1);
src/lib/scroll16.c:				//modexprintbig(page, x, y, 1, 15, 0, (t->debug_data));
src/lib/scroll16.c://						modexprint(page, x+(textx*8), y+(texty*8), 1, (word)(t->debug_data), 0, (t->debug_data));
src/lib/scroll16.c:	i=ty * mv->map->width + tx;
src/lib/scroll16.c:	for(x=poopoffset; x<(mv->page->sw+mv->dxThresh)/(poopoffset+1) && tx < mv->map->width; x+=mv->map->tiles->tileWidth, tx++) {
src/lib/scroll16.c:		mapDrawTile(mv->map->tiles, mv->map->data[i], mv->page, x, y);
src/lib/scroll16.c:	i=ty * mv->map->width + tx;
src/lib/scroll16.c:	for(y=poopoffset; y<(mv->page->sh+mv->dyThresh)/(poopoffset+1) && ty < mv->map->height; y+=mv->map->tiles->tileHeight, ty++) {
src/lib/scroll16.c:		mapDrawTile(mv->map->tiles, mv->map->data[i], mv->page, x, y);
src/lib/scroll16.c:	i += mv->map->width;
src/lib/scroll16.c:	i=ty * mv->map->width + tx;
src/lib/scroll16.c:	for(x=0; x<mv->page->sw+mv->dxThresh && tx < mv->map->width; x+=mv->map->tiles->tileWidth, tx++) {
src/lib/scroll16.c:		mapDrawTile(mv->map->tiles, mv->map->data[i], mv->page, x, y);
src/lib/scroll16.c:	i=ty * mv->map->width + tx;
src/lib/scroll16.c:	for(y=0; y<mv->page->sh+mv->dyThresh && ty < mv->map->height; y+=mv->map->tiles->tileHeight, ty++) {
src/lib/scroll16.c:		mapDrawTile(mv->map->tiles, mv->map->data[i], mv->page, x, y);
src/lib/scroll16.c:	i += mv->map->width;
src/lib/scroll16.c:	word x = (0) + gv->video.page[/*!*/(gv->video.p)].dx; // follow the screen
src/lib/scroll16.c:	word y = (0) + gv->video.page[/*!*/(gv->video.p)].dy; // follow the screen
src/lib/scroll16.c://	modexCopyPageRegion(&(gv->video.page[shinku_fps_indicator_page]), &(gv->video.page[!shinku_fps_indicator_page]), x, y, x+w, 0, w, h);
src/lib/scroll16.c:// 	o =	*(gv->video.page[2].data); // source offscreen
src/lib/scroll16.c:// 	o2 =	*(gv->video.page[shinku_fps_indicator_page].data)+(y * vga_state.vga_stride) + (x >> 2); // dest visible (original stride)
src/lib/scroll16.c:	if(elapsed_timer(gv) >= (1.0 / gv->kurokku.frames_per_second))
src/lib/scroll16.c:        // NTS: For some bizarre reason, gv->pee is not initialized, but the pointer is not NULL even
src/lib/scroll16.c:        //      though it should be. Instead it's NULL as a near pointer but contains a non-null
src/lib/scroll16.c:		sprintf(global_temp_status_text, "%.0f fps", (double)gv->kurokku.tiku/ticktock(gv));
src/lib/scroll16.c:		//modexClearRegion(&(gv->video.page[shinku_fps_indicator_page]), x, y, w, h, 45);
src/lib/scroll16.c:		modexprint(&(gv->video.page[/*!*/(gv->video.p)]), x, y, type, col, bgcol, global_temp_status_text);
src/lib/scroll16.c:		gv->kurokku.tiku=0;
src/lib/scroll16.c:// 		o =	*(gv->video.page[shinku_fps_indicator_page].data); // source offscreen
src/lib/scroll16.c:// 		o2 =	*(gv->video.page[2].data)+(y * vga_state.vga_stride) + (x >> 2); // dest visible (original stride)
src/lib/scroll16.c://		modexCopyPageRegion(&(gv->video.page[shinku_fps_indicator_page]), &(gv->video.page[!shinku_fps_indicator_page]), x, y, x, 0, w, h);
src/lib/scroll16.c:	gv->kurokku.tiku++;
src/lib/scroll16.c:	switch(gv->kurokku.fpscap)
src/lib/scroll16.c:			//modexprint(&(gv->video.page[shinku_fps_indicator_page]), x, y+8, type, col, bgcol, "sanic!");
src/lib/scroll16.c:			gv->kurokku.frames_per_second=1;
src/lib/scroll16.c:			gv->kurokku.frames_per_second=60;
src/lib/scroll16.c:	if(gv->video.r){
src/lib/scroll16.c:		//_fmemcpy((gv->video.page[(gv->video.p)]).data, (gv->video.page[(!gv->video.p)]).data, gv->video.page[(!gv->video.p)].pagesize);
src/lib/scroll16.c:		if(!pageploop) modexCopyPageRegion(&(gv->video.page[(gv->video.p)]), &(gv->video.page[(!gv->video.p)]), 0, 0, 0, 0, gv->video.page[gv->video.p].width, gv->video.page[!gv->video.p].height);
src/lib/scroll16.c:		modexShowPage(&(gv->video.page[gv->video.p]));
src/lib/scroll16.c:		if(!pageploop) gv->video.p=!gv->video.p;
src/lib/scroll16.c:		gv->video.r=!gv->video.r;
src/lib/scroll16.c:		//0000gv->video.tickclk = ((*clockw)-gv->video.startclk)/18.2;
src/lib/scroll16.c:	//x-=4;
src/lib/scroll16.c:	y-=pip[0].map->tiles->tileHeight;
src/lib/scroll16.c:			y-=qq;
src/lib/scroll16.c:			by-=4;
src/lib/scroll16.c:			dire*=(player[pn].d-2);
src/lib/scroll16.c:			dire*=(player[pn].d-2);
src/lib/scroll16.c:			x-=qq;
src/lib/scroll16.c:			bx-=4;
src/lib/scroll16.c:#define FRAME1 PBUFSFUN(pip[/*!*/(pip->video->p)].page, x, y, 48, dire, 24, 32,	PLAYERBMPDATA);
src/lib/scroll16.c:#define FRAME2 PBUFSFUN(pip[/*!*/(pip->video->p)].page, x, y, 24, dire, 24, 32,	PLAYERBMPDATA);
src/lib/scroll16.c:#define FRAME3 PBUFSFUN(pip[/*!*/(pip->video->p)].page, x, y, 0, dire, 24, 32,	PLAYERBMPDATA);
src/lib/scroll16.c:#define FRAME4 PBUFSFUN(pip[/*!*/(pip->video->p)].page, x, y, 24, dire, 24, 32,	PLAYERBMPDATA);
src/lib/scroll16.c:#define FRAME1 modexClearRegion(pip[/*!*/(pip->video->p)].page, x, y, 24, 32, 2+dire);
src/lib/scroll16.c:#define FRAME2 modexClearRegion(pip[/*!*/(pip->video->p)].page, x, y, 24, 32, 1+dire);
src/lib/scroll16.c:#define FRAME3 modexClearRegion(pip[/*!*/(pip->video->p)].page, x, y, 24, 32, dire);
src/lib/scroll16.c:#define FRAME4 modexClearRegion(pip[/*!*/(pip->video->p)].page, x, y, 24, 32, 1+dire);
src/lib/scroll16.c:		modexCopyPageRegion(pip[1].page, pip[0].page, x-4, y-4, x-4, y-4, 28, 36);
src/lib/scroll16.c:	//modexCopyPageRegion(pip[3].page, pip[!(pip->video->p)].page, x-4, y-4, 0, 128, 28, 36);
src/lib/scroll16.c:	/*modexCopyPageRegion(pip[pip->video->p].page,
src/lib/scroll16.c: pip[!(pip->video->p)].page, x-4, y-4, x-4, y-4, 28, 36);*/
src/lib/scroll16.c://	else modexCopyPageRegion(pip[1].page, pip[0].page, x-4, y-4, x-4, y-4, 28, 40);
src/lib/scroll16.c:	pip->video->r=1;
src/lib/scroll16.c:	switch(ent->d)
src/lib/scroll16.c:			dx = -dx;
src/lib/scroll16.c:			dy = -dy;
src/lib/scroll16.c:	if(coll_check(ent->x, ent->y, dx, dy,  map_v))
src/lib/scroll16.c:	if(ZC_walk(player->ent, map_v) && boundary_check(map_v->tx, map_v->ty, dx, dy, map_v->map->width - 2*map_v->page->tilesw, map_v->map->height - 2*map_v->page->tilesh))
src/lib/scroll16.c:	mv->delta += player->dx | player->dy;
src/lib/scroll16.c:	delta = mv->delta;
src/lib/scroll16.c:	mv->d = (player->dx) ? (player->dx > 0) ? 3 : 1 : (player->dy) ? (player->dy > 0) ? 4 : 0 : 2;
src/lib/scroll16.c:	switch(mv->d){
src/lib/scroll16.c:			c = -1;
src/lib/scroll16.c:			delta = -delta;
src/lib/scroll16.c:			if(!(delta + mv->dxThresh))
src/lib/scroll16.c:				mv->delta = 0;
src/lib/scroll16.c:				mv->ty += c;
src/lib/scroll16.c:			c = -1;
src/lib/scroll16.c:			delta = -delta;
src/lib/scroll16.c:			if(!(delta + mv->dyThresh))
src/lib/scroll16.c:				mv->delta = 0;
src/lib/scroll16.c:				mv->tx += c;
src/lib/scroll16.c:	mv->video->r=1;
src/lib/scroll16.h: * Copyright (C) 2012-2016 sparky4 & pngwen & andrius4669 & joncampbell123 & yakui-lover
src/lib/scroll16.h: * Fifth Floor, Boston, MA 02110-1301 USA.
src/lib/scroll16.h: * 	should have a sprite too. Map is drawn left-to-right, top-to-bottom.
src/lib/scroll16.h://++++	printf("Total used: %zu\n", oldfreemem-GetFreeSize());
src/lib/scroll16.h://printf("map.width=%d	map.height=%d	map.data[0]=%d\n", mv[0].map->width, mv[0].map->height, mv[0].map->data[0]);
src/lib/scroll16.h:	printf("	tile data value at player trigger position: %d\n\n", mv[0].map->data[(player[0].triggerx-1)+(map.width*(player[0].triggery-1))]);\
src/lib/tst.c:	if (t->type == JSMN_PRIMITIVE) {
src/lib/tst.c:		printf("%.*s", t->end - t->start, js+t->start);
src/lib/tst.c:	} else if (t->type == JSMN_STRING) {
src/lib/tst.c:		printf("'%.*s'", t->end - t->start, js+t->start);
src/lib/tst.c:	} else if (t->type == JSMN_OBJECT) {
src/lib/tst.c:		for (i = 0; i < t->size; i++) {
src/lib/tst.c:			j += dump(js, t+1+j, count-j, indent+1);
src/lib/tst.c:			j += dump(js, t+1+j, count-j, indent+1);
src/lib/tst.c:	} else if (t->type == JSMN_ARRAY) {
src/lib/tst.c:		for (i = 0; i < t->size; i++) {
src/lib/tst.c:			for (k = 0; k < indent-1; k++) printf("  ");
src/lib/tst.c:			printf("   - ");
src/lib/tst.c:			j += dump(js, t+1+j, count-j, indent+1);
src/lib/xms.c: * Documentation on the XMS API was found on http://www.qzx.com/pc-gpe/xms30.txt
src/lib/xms.c:/* Set up the XMS driver, returns 0 on success and non-zero on failure */
src/lib/xms.c:	/* It is not possible to allocate more kilobytes than a 16-bit register can hold :-) */
src/lib/xms.c:	/* Get the next free entry in the handle <-> pointer mapping */
src/lib/xms.c:	/* Create an entry in the handle <-> pointer mapping */
src/lib/xms.c:			/* Clear handle <-> pointer map entry so it can be reused */
src/lib/xms.h:/* Mapping of XMS handle <-> normal pointer */

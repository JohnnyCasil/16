-------------------------------------------------------------------------------
					./q.sh start
-------------------------------------------------------------------------------
src/imfplay.c:	printf("bigbuffer	%Fp\t", gvar->ca.audiosegs[0]);\
src/imfplay.c:	printf("&%Fp\n", MEMPTR gvar->ca.audiosegs[0]);\
src/imfplay.c:	MM_FreePtr(MEMPTR gvar->ca.audiosegs[0], gvar);
src/imfplay.c:	MM_GetPtr(MEMPTR gvar->ca.audiosegs[0],len, gvar);
src/imfplay.c:	imf_music = (struct imf_entry *)gvar->ca.audiosegs[0];
src/lib/16_ca.c:	value = *(long far *)(((byte far *)gvar->ca.grstarts)+offset);
src/lib/16_ca.c:#define	GRFILEPOS(c) (gvar->ca.grstarts[c])
src/lib/16_ca.c:	gvar->handle.debughandle = open("debug.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.debughandle = open("debug.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	close(gvar->handle.debughandle);
src/lib/16_ca.c:	if(gvar->pm.emm.EMSVer<0x40)
src/lib/16_ca.c:	if(gvar->pm.emm.EMSVer<0x40)
src/lib/16_ca.c:	MM_GetPtr (MEMPTR gvar->ca.tinf,length,gvar);
src/lib/16_ca.c:	CA_FarRead(handle, gvar->ca.tinf, length,gvar);
src/lib/16_ca.c:	gvar->ca.tinf = (byte _seg *)FP_SEG(&maphead);
src/lib/16_ca.c:	if ((gvar->ca.file.maphandle[0] = open("data/test.map",
src/lib/16_ca.c:if ((gvar->ca.file.audiohandle = open("data/02.imf",
src/lib/16_ca.c:	gvar->handle.profilehandle = open("profile.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.profilehandle = open("profile.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.showmemhandle = open("meminfo.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->handle.showmemhandle = open("meminfo.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_ca.c:	gvar->ca.camap.mapon = -1;
src/lib/16_ca.c:	gvar->ca.ca_levelbit = 1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum = 0;
src/lib/16_ca.c:	close(gvar->handle.profilehandle);
src/lib/16_ca.c: 	close(gvar->handle.showmemhandle);
src/lib/16_ca.c:	close(*(gvar->ca.file.maphandle));
src/lib/16_ca.c:	gvar->ca.grneeded[chunk] |= ca_levelbit;		// make sure it doesn't get removed
src/lib/16_ca.c:	if (gvar->ca.camap.mapon>-1 && gvar->ca.camap.mapheaderseg[gvar->ca.camap.mapon])
src/lib/16_ca.c:		MM_SetPurge (((memptr)gvar->ca.camap.mapheaderseg[(gvar->ca.camap.mapon)]), 3, gvar);
src/lib/16_ca.c:		if (gvar->ca.camap.mapsegs[plane])
src/lib/16_ca.c:			MM_FreePtr ((memptr)gvar->ca.camap.mapsegs[plane], gvar);
src/lib/16_ca.c:	gvar->ca.camap.mapon = gvar->ca.camap.mapnum;
src/lib/16_ca.c://	if (!gvar->ca.camap.mapheaderseg[gvar->ca.camap.mapnum])
src/lib/16_ca.c://		//pos = ((_seg *)gvar->ca.camap.tinf)->headeroffsets[gvar->ca.camap.mapnum];
src/lib/16_ca.c://		pos = ((memptr)gvar->ca.camap.tinf)->headeroffsets[gvar->ca.camap.mapnum];
src/lib/16_ca.c://		MM_GetPtr(MEMPTR gvar->ca.camapheaderseg[mapnum],sizeof(maptype));
src/lib/16_ca.c://		MM_SetPurge (MEMPTR mapheaderseg[mapnum], 0, &(gvar->mm));
src/lib/16_ca.c:	if (gvar->ca.ca_levelnum==7)
src/lib/16_ca.c:	gvar->ca.ca_levelbit<<=1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum++;
src/lib/16_ca.c:	if (!gvar->ca.ca_levelnum)
src/lib/16_ca.c:	gvar->ca.ca_levelbit>>=1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum--;
src/lib/16_ca.c:		gvar->ca.grneeded[i]&=~gvar->ca.ca_levelbit;
src/lib/16_ca.c:	_fmemset (gvar->ca.grneeded,0,sizeof(gvar->ca.grneeded));
src/lib/16_ca.c:	gvar->ca.ca_levelbit = 1;
src/lib/16_ca.c:	gvar->ca.ca_levelnum = 0;
src/lib/16_ca.c:		if (gvar->ca.grsegs[i])
src/lib/16_ca.c:			MM_SetPurge (gvar->ca.grsegs[i],3, gvar);
src/lib/16_ca.c://		if (gvar->ca.camap.mapheaderseg[i])
src/lib/16_ca.c://			MM_SetPurge (gvar->ca.camap.mapheaderseg[i],3, gvar);
src/lib/16_ca.c:		if (gvar->ca.mapsegs[i])
src/lib/16_ca.c:			MM_FreePtr ((memptr *)&gvar->ca.mapsegs[i], gvar);
src/lib/16_ca.c:		if (gvar->ca.audiosegs[i])
src/lib/16_ca.c:			MM_SetPurge ((memptr *)&gvar->ca.audiosegs[i],3, gvar);
src/lib/16_ca.c:		if (gvar->ca.grneeded[i]&(gvar->ca.ca_levelbit))//if (grneeded[i]&ca_levelbit)
src/lib/16_ca.c:			if (gvar->ca.grsegs[i])					// its allready in memory, make
src/lib/16_ca.c:				MM_SetPurge(gvar->ca.grsegs[i],0,gvar);	// sure it stays there!
src/lib/16_ca.c:			if (gvar->ca.grsegs[i])					// not needed, so make it purgeable
src/lib/16_ca.c:				MM_SetPurge(gvar->ca.grsegs[i],3,gvar);
src/lib/16_ca.c:		if ( (gvar->ca.grneeded[i]&(gvar->ca.ca_levelbit)) && !gvar->ca.grsegs[i])
src/lib/16_ca.c:						!(gvar->video.grneeded[next]&ca_levelbit && !grsegs[next]))
src/lib/16_ca.c:					CA_FarRead(grhandle,(gvar->mm.bufferseg),endpos-pos,gvar);
src/lib/16_dbg.c:		page = &(gvar->pm.PMPages[i]);
src/lib/16_dbg.c://++		if (i < (gvar->pm.fi.PMSpriteStart))
src/lib/16_dbg.c:/*		else if (i < (gvar->pm.fi.PMSoundStart))
src/lib/16_dbg.c:		else if (i == (gvar->pm.fi.ChunksInFile - 1))
src/lib/16_dbg.c:		while (!(scan = gvar->in.inst->LastScan))
src/lib/16_dbg.c:			if (++i >= (gvar->pm.fi.ChunksInFile))
src/lib/16_dbg.c://			i = (gvar->pm.fi.PMSpriteStart);
src/lib/16_dbg.c://			i = (gvar->pm.fi.PMSoundStart);
src/lib/16_dbg.c:			i = (gvar->pm.fi.ChunksInFile - 1);
src/lib/16_dbg.c:			for (j = 0;j < (gvar->pm.fi.ChunksInFile);j++)
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:		write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:		write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:		write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:	write(gvar->handle.heaphandle,scratch,strlen(scratch));
src/lib/16_hc.c:	write(gvar->handle.heaphandle,(str),strlen((str)));
src/lib/16_hc.c:	gvar->handle.heaphandle = open("heap.16b", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_hc.c:	gvar->handle.heaphandle = open("heap.16w", O_CREAT | O_WRONLY | O_TEXT);
src/lib/16_hc.c:	close(gvar->handle.heaphandle);
src/lib/16_in.c://gvar->in.KbdDefs = {0x1d,0x38,/*0x47,*/0x48,/*0x49,*/0x4b,0x4d,/*0x4f,*/0x50/*,0x51*/};
src/lib/16_in.c:	def = gvar->in.JoyDefs + joy;
src/lib/16_in.c:	def = &(gvar->in.JoyDefs[joy]);
src/lib/16_in.c:	def = &(gvar->in.JoyDefs[joy]);
src/lib/16_in.c:	gvar->in.JoysPresent[joy] = false;
src/lib/16_in.c:	if (gvar->in.IN_Started)
src/lib/16_in.c:	gvar->in.MousePresent = checkmouse? INL_StartMouse() : false;
src/lib/16_in.c:		gvar->in.JoysPresent[i] = checkjoys? INL_StartJoy(i, gvar) : false;
src/lib/16_in.c:	gvar->in.inst = &inst;
src/lib/16_in.c:	gvar->in.IN_Started = true;
src/lib/16_in.c:	|| 	((nt == ctrl_Joystick1) && !gvar->in.JoysPresent[0])
src/lib/16_in.c:	|| 	((nt == ctrl_Joystick2) && !gvar->in.JoysPresent[1])
src/lib/16_in.c:	|| 	((nt == ctrl_Mouse) && !gvar->in.MousePresent)
src/lib/16_in.c:	gvar->in.KbdDefs[0].button0 = 0x1c;
src/lib/16_in.c:	gvar->in.KbdDefs[0].button1 = 0x38;
src/lib/16_in.c:	gvar->in.KbdDefs[0].up = 0x48;
src/lib/16_in.c:	gvar->in.KbdDefs[0].left = 0x4b;
src/lib/16_in.c:	gvar->in.KbdDefs[0].right = 0x4d;
src/lib/16_in.c:	gvar->in.KbdDefs[0].down = 0x50;
src/lib/16_in.c:	if (!gvar->in.IN_Started)
src/lib/16_in.c:	gvar->in.IN_Started = false;
src/lib/16_in.c:	if (gvar->in.MousePresent)
src/lib/16_in.c:		if (!gvar->in.JoysPresent[i])
src/lib/16_in.c:			def = &(gvar->in.KbdDefs[type - ctrl_Keyboard]);
src/lib/16_in.c:	if (gvar->in.MousePresent)
src/lib/16_in.c:	if(!gvar->in.IN_Started)
src/lib/16_in.c:	if (gvar->in.MousePresent)
src/lib/16_in.c:	if (gvar->in.MousePresent)
src/lib/16_in.c:		if (gvar->in.JoysPresent[i])
src/lib/16_in.c:	if (gvar->in.MousePresent)
src/lib/16_map.c:#define MAPBUFINLM *(gvar->ca.mapsegs)
src/lib/16_mm.c:	gvar->mm.totalEMSpages=totalEMSpages;
src/lib/16_mm.c:	gvar->mm.freeEMSpages=freeEMSpages;
src/lib/16_mm.c:	gvar->mm.EMSPageFrame=EMSPageFrame;
src/lib/16_mm.c:	gvar->mm.EMSpagesmapped=EMSpagesmapped;
src/lib/16_mm.c:	gvar->mm.EMSHandle=EMSHandle;
src/lib/16_mm.c:	gvar->mm.EMSVer=EMSVer;
src/lib/16_mm.c:	unsigned EMSHandle=gvar->mm.EMSHandle;
src/lib/16_mm.c:	EMSHandle=gvar->mm.EMSHandle;
src/lib/16_mm.c:	gvar->mmi.EMSmem = (i)*0x4000lu;
src/lib/16_mm.c:	EMSHandle=gvar->mm.EMSHandle;
src/lib/16_mm.c:	if(gvar->mm.EMSVer<0x40)
src/lib/16_mm.c:	gvar->mmi.EMSmem = (i)*0x4000lu;
src/lib/16_mm.c:	gvar->mmi.XMSmem += size*16;
src/lib/16_mm.c:	gvar->mm.UMBbase[gvar->mm.numUMBs] = base;
src/lib/16_mm.c:	gvar->mm.numUMBs++;
src/lib/16_mm.c:	if(gvar->mm.numUMBs < MAXUMBS)
src/lib/16_mm.c:	for (i=0;i<gvar->mm.numUMBs;i++)
src/lib/16_mm.c:		base = gvar->mm.UMBbase[i];
src/lib/16_mm.c:	scan = last = gvar->mm.mmhead;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// reset rover to start of memory
src/lib/16_mm.c:		gvar->mm.mmnew->useptr = NULL;
src/lib/16_mm.c:		gvar->mm.mmnew->next = scan->next;
src/lib/16_mm.c:		scan->next = gvar->mm.mmnew;
src/lib/16_mm.c:		gvar->mm.mmnew->start = segstart+seglength;
src/lib/16_mm.c:		gvar->mm.mmnew->length = extra;
src/lib/16_mm.c:		gvar->mm.mmnew->attributes = LOCKBIT;
src/lib/16_mm.c:	scan = gvar->mm.mmhead->next;
src/lib/16_mm.c:	if(gvar->mm.mmstarted)
src/lib/16_mm.c:	gvar->mm.mmstarted = true;
src/lib/16_mm.c:	gvar->mm.bombonerror = true;
src/lib/16_mm.c:	gvar->mm.mmhead = NULL;
src/lib/16_mm.c:	gvar->mm.mmfree = &(gvar->mm.mmblocks[0]);
src/lib/16_mm.c:		gvar->mm.mmblocks[i].next = &(gvar->mm.mmblocks[i+1]);
src/lib/16_mm.c:	gvar->mm.mmblocks[i].next = NULL;
src/lib/16_mm.c:	gvar->mm.mmhead = gvar->mm.mmnew;				// this will allways be the first node
src/lib/16_mm.c:	gvar->mm.mmnew->start = 0;
src/lib/16_mm.c:	gvar->mm.mmnew->length = 0xffff;
src/lib/16_mm.c:	gvar->mm.mmnew->attributes = LOCKBIT;
src/lib/16_mm.c:	gvar->mm.mmnew->next = NULL;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:	//start = gvar->mm.nearheap = _fmalloc(length);
src/lib/16_mm.c:	start = (void __far *)(gvar->mm.nearheap = _nmalloc(length));
src/lib/16_mm.c:	start = (void far *)(gvar->mm.nearheap = malloc(length));
src/lib/16_mm.c:	gvar->mmi.nearheap = length;
src/lib/16_mm.c:	start = gvar->mm.farheap = _fmalloc(length);//start = gvar->mm.farheap = halloc(length, 1);
src/lib/16_mm.c:	gvar->mmi.farheap = length;
src/lib/16_mm.c:	gvar->mmi.mainmem = gvar->mmi.nearheap + gvar->mmi.farheap;
src/lib/16_mm.c:	gvar->mmi.EMSmem = 0;
src/lib/16_mm.c:		MML_UseSpace(gvar->mm.EMSPageFrame,(MAPPAGES)*0x4000lu, gvar);
src/lib/16_mm.c:		//if(gvar->pm.emm.EMSVer<0x40)
src/lib/16_mm.c:	gvar->mmi.XMSmem = 0;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;		// start looking for space after low block
src/lib/16_mm.c:	MM_GetPtr(&(gvar->mm.bufferseg),BUFFERSIZE, gvar);
src/lib/16_mm.c:	if(!(gvar->mm.mmstarted))
src/lib/16_mm.c:	_ffree(gvar->mm.farheap);//	printf("		far freed\n");
src/lib/16_mm.c:	_nfree(gvar->mm.nearheap);//	printf("		near freed\n");
src/lib/16_mm.c:	free(gvar->mm.nearheap);//	printf("		near freed\n");
src/lib/16_mm.c:	gvar->mm.mmnew->length = needed;
src/lib/16_mm.c:	gvar->mm.mmnew->useptr = baseptr;
src/lib/16_mm.c:	//if(gvar->mm.mmnew->useptr==NULL){
src/lib/16_mm.c:		printf("	baseptr=%Fp	", baseptr); printf("useptr=%Fp\n", gvar->mm.mmnew->useptr);
src/lib/16_mm.c:		printf("	*baseptr=%Fp	", *baseptr); printf("*useptr=%Fp\n", *(gvar->mm.mmnew->useptr));
src/lib/16_mm.c:		printf("	&baseptr=%Fp	", &baseptr); printf("&useptr=%Fp\n", &(gvar->mm.mmnew->useptr));
src/lib/16_mm.c:	//Quit(gvar, "gvar->mm.mmnew->useptr==NULL"); }
src/lib/16_mm.c:	gvar->mm.mmnew->attributes = BASEATTRIBUTES;
src/lib/16_mm.c:		if (search == 1 && gvar->mm.mmrover == gvar->mm.mmhead)
src/lib/16_mm.c:			lastscan = gvar->mm.mmrover;
src/lib/16_mm.c:			scan = gvar->mm.mmrover->next;
src/lib/16_mm.c:			lastscan = gvar->mm.mmhead;
src/lib/16_mm.c:			scan = gvar->mm.mmhead->next;
src/lib/16_mm.c:			endscan = gvar->mm.mmrover;
src/lib/16_mm.c:			lastscan = gvar->mm.mmhead;
src/lib/16_mm.c:			scan = gvar->mm.mmhead->next;
src/lib/16_mm.c:				lastscan->next = gvar->mm.mmnew;
src/lib/16_mm.c:				gvar->mm.mmnew->start = *(unsigned *)baseptr = startseg;
src/lib/16_mm.c:				gvar->mm.mmnew->next = scan;
src/lib/16_mm.c:				gvar->mm.mmrover = gvar->mm.mmnew;
src/lib/16_mm.c:	if (gvar->mm.bombonerror)
src/lib/16_mm.c:		printf(OUT_OF_MEM_MSG,(size-gvar->mmi.nearheap));
src/lib/16_mm.c:		gvar->mm.mmerror = true;
src/lib/16_mm.c:	last = gvar->mm.mmhead;
src/lib/16_mm.c:	if(baseptr == gvar->mm.mmrover->useptr)	// removed the last allocated block
src/lib/16_mm.c:		gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:	start = gvar->mm.mmrover;
src/lib/16_mm.c:		if(gvar->mm.mmrover->useptr == baseptr)
src/lib/16_mm.c:		gvar->mm.mmrover = gvar->mm.mmrover->next;
src/lib/16_mm.c:		if(!gvar->mm.mmrover)
src/lib/16_mm.c:			gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:		else if(gvar->mm.mmrover == start)
src/lib/16_mm.c:	gvar->mm.mmrover->attributes &= ~PURGEBITS;
src/lib/16_mm.c:	gvar->mm.mmrover->attributes |= purge;
src/lib/16_mm.c:	start = gvar->mm.mmrover;
src/lib/16_mm.c:		if(gvar->mm.mmrover->useptr == baseptr)
src/lib/16_mm.c:		gvar->mm.mmrover = gvar->mm.mmrover->next;
src/lib/16_mm.c:		if(!gvar->mm.mmrover)
src/lib/16_mm.c:			gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:		else if(gvar->mm.mmrover == start)
src/lib/16_mm.c:	gvar->mm.mmrover->attributes &= ~LOCKBIT;
src/lib/16_mm.c:	gvar->mm.mmrover->attributes |= locked*LOCKBIT;
src/lib/16_mm.c:	oldborder = gvar->video.bordercolor;
src/lib/16_mm.c:	gvar->video.bordercolor = modexPalOverscan(15);
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:	gvar->mm.mmrover = gvar->mm.mmhead;
src/lib/16_mm.c:	VL_SetLineWidth(40, &gvar->video.ofs);
src/lib/16_mm.c:	temp = gvar->video.ofs.bufferofs;
src/lib/16_mm.c:	gvar->video.ofs.bufferofs = gvar->video.ofs.displayofs;
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:			write(gvar->handle.debughandle,scratch,strlen(scratch));
src/lib/16_mm.c:		VW_Hlin(x,x+end,y,color, &gvar->video.ofs);
src/lib/16_mm.c:		VL_Plot(x,y,15, &gvar->video.ofs);
src/lib/16_mm.c:			VW_Hlin(x+end+1,x+(scan->next->start-scan->start),y,0, &gvar->video.ofs);	// black = free
src/lib/16_mm.c:		write(gvar->handle.debughandle,scratch,strlen(scratch));
src/lib/16_mm.c:		write(gvar->handle.debughandle,scratch0,strlen(scratch0));
src/lib/16_mm.c:	gvar->video.ofs.bufferofs = temp;
src/lib/16_mm.c:	_nfree(gvar->mm.nearheap);
src/lib/16_mm.c:	free(gvar->mm.nearheap);
src/lib/16_mm.c:		scan = gvar->mm.mmhead;
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:	scan = gvar->mm.mmhead;
src/lib/16_mm.c:		printf("	%cLIMEMS	%u\n", 0xC9, gvar->pm.emm.EMSPresent);
src/lib/16_mm.c:		printf("	%c%cEMM v%x.%x available\n", 0xC7, 0xC4, gvar->pm.emm.EMSVer>>4,gvar->pm.emm.EMSVer&0x0F);
src/lib/16_mm.c:		printf("	%c%ctotalEMSpages:	%u	", 0xC7, 0xC4, gvar->pm.emm.totalEMSpages); printf("freeEMSpages:	%u\n", gvar->pm.emm.freeEMSpages);
src/lib/16_mm.c:		printf("	%c%cEMSPageFrame:	%04x\n", 0xC7, 0xC4, gvar->pm.emm.EMSPageFrame);
src/lib/16_mm.c:		printf("	%c%cEMSmem:	%lu or %luk\n", 0xD3, 0xC4, gvar->mmi.EMSmem, gvar->mmi.EMSmem/1204);
src/lib/16_mm.c:		printf("	%cXMS	%u\n", 0xC9, gvar->pm.xmm.XMSPresent);
src/lib/16_mm.c:		printf("	%c%cXMSHandle:	%04x\n", 0xC7, 0xC4, gvar->pm.xmm.XMSHandle);
src/lib/16_mm.c:		printf("	%c%cXMSmem:	%lu or %lukb\n", 0xD3, 0xC4, gvar->mmi.XMSmem, gvar->mmi.XMSmem/1024);
src/lib/16_mm.c:	printf("	%cConv.	%u\n", 0xC9, gvar->pm.mm.MainPresent); DebugMemory_(gvar, 0);
src/lib/16_mm.c:	//printf("mainmem:	%lu\n", gvar->mmi.mainmem);
src/lib/16_mm.c:	//printf("Total convmem:	%lu	", gvar->mmi.mainmem); printf("TotalFree:	%lu	", MM_TotalFree(gvar)+gvar->mmi.EMSmem+gvar->mmi.XMSmem+gvar->mmi.XMSmem); printf("TotalUsed:	%lu\n", gvar->mmi.mainmem);
src/lib/16_mm.c:	printf("nearheap:	%lu		", gvar->mmi.nearheap); printf("farheap:	%lu\n", gvar->mmi.farheap);
src/lib/16_mm.c:	gvar->mm.bombonerror = bomb;
src/lib/16_mm.c:	if(!gvar->mm.mmfree)
src/lib/16_mm.c:	gvar->mm.mmnew=gvar->mm.mmfree;
src/lib/16_mm.c:	gvar->mm.mmfree=gvar->mm.mmfree->next;
src/lib/16_mm.c:	if(!(gvar->mm.mmnew=gvar->mm.mmfree))
src/lib/16_mm.c:	gvar->mm.mmfree=gvar->mm.mmfree->next;
src/lib/16_mm.c:	x->next=gvar->mm.mmfree;
src/lib/16_mm.c:	gvar->mm.mmfree=x;
src/lib/16_mm.c:	dword XMSDriver = gvar->pm.xmm.XMSDriver;
src/lib/16_pm.c:	PMBlockAttr		gvar->pm.mm.MainMemUsed[PMMaxMainMem];
src/lib/16_pm.c:	int				gvar->pm.mm.MainPagesAvail;*/
src/lib/16_pm.c:/*	word			gvar->pm.emm.EMSAvail,gvar->pm.emm.EMSPagesAvail,gvar->pm.emm.EMSHandle,
src/lib/16_pm.c:					gvar->pm.emm.EMSPageFrame,gvar->pm.emm.EMSPhysicalPage;
src/lib/16_pm.c:	gvar->pm.emm.EMSListStruct	gvar->pm.emm.EMSList[EMSFrameCount];*/
src/lib/16_pm.c:	//word			gvar->pm.xmm.XMSAvail,gvar->pm.xmm.XMSPagesAvail,gvar->pm.xmm.XMSHandle;
src/lib/16_pm.c:/*	int				gvar->pm.xmm.XMSProtectPage = -1;
src/lib/16_pm.c:	char			gvar->pm.fi.PageFileName[13] = {"VSWAP."};
src/lib/16_pm.c:	word			gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:					gvar->pm.PMPanicMode,
src/lib/16_pm.c:					gvar->pm.PMThrashing;
src/lib/16_pm.c:	word			gvar->pm.XMSPagesUsed,
src/lib/16_pm.c:					gvar->pm.EMSPagesUsed,
src/lib/16_pm.c:					gvar->pm.PMNumBlocks;
src/lib/16_pm.c:	PageListStruct	far *gvar->pm.PMPages,
src/lib/16_pm.c:					_seg *gvar->pm.PMSegPages;*/
src/lib/16_pm.c:	EMShandle=gvar->pm.emm.EMSHandle;
src/lib/16_pm.c:	gvar->pm.emm.EMSPresent = false;			// Assume that we'll fail
src/lib/16_pm.c:	gvar->pm.emm.EMSAvail = gvar->mmi.EMSmem = 0;
src/lib/16_pm.c:		size = gvar->pm.emm.EMSAvail * (long)EMSPageSize;
src/lib/16_pm.c:		if (size - (EMSPageSize * 2) > (gvar->pm.fi.ChunksInFile * (long)PMPageSize))
src/lib/16_pm.c:			size = (gvar->pm.fi.ChunksInFile * (long)PMPageSize) + EMSPageSize;
src/lib/16_pm.c:			gvar->pm.emm.EMSAvail = size / EMSPageSize;
src/lib/16_pm.c:		return(gvar->pm.emm.EMSPresent);
src/lib/16_pm.c:	gvar->mmi.EMSmem = EMSAvail * (dword)EMSPageSize;
src/lib/16_pm.c:		gvar->pm.emm.EMSList[i].baseEMSPage = -1;
src/lib/16_pm.c:	gvar->pm.emm.EMSPresent = true;			// We have EMS
src/lib/16_pm.c:	gvar->pm.emm.EMSPageFrame = EMSPageFrame;
src/lib/16_pm.c:	gvar->pm.emm.EMSAvail = EMSAvail;
src/lib/16_pm.c:	gvar->pm.emm.EMSVer = EMSVer;
src/lib/16_pm.c:	gvar->pm.emm.EMSHandle = EMSHandle;
src/lib/16_pm.c:	gvar->pm.emm.freeEMSpages = freeEMSpages;
src/lib/16_pm.c:	gvar->pm.emm.totalEMSpages = totalEMSpages;
src/lib/16_pm.c:	return(gvar->pm.emm.EMSPresent);
src/lib/16_pm.c:	EMSHandle=gvar->pm.emm.EMSHandle;
src/lib/16_pm.c:	if (gvar->pm.emm.EMSPresent)
src/lib/16_pm.c:	gvar->pm.xmm.XMSPresent = false;					// Assume failure
src/lib/16_pm.c:	XMSAvail = gvar->mmi.XMSmem = 0;
src/lib/16_pm.c:		gvar->mmi.XMSmem = (dword)(XMSAvail) * 1024;
src/lib/16_pm.c:		gvar->pm.xmm.XMSAvail = XMSAvail;
src/lib/16_pm.c:		gvar->pm.xmm.XMSHandle = XMSHandle;
src/lib/16_pm.c:		//gvar->pm.xmm.XMSVer = XMSVer;
src/lib/16_pm.c:		gvar->pm.xmm.XMSPresent = true;
src/lib/16_pm.c:		printf("	XMSmem=%lu	XMSAvail=%u\n", gvar->mmi.XMSmem, XMSAvail);
src/lib/16_pm.c:		//printf("	%u", gvar->pm.xmm.XMSHandle);
src/lib/16_pm.c:	return(gvar->pm.xmm.XMSPresent);
src/lib/16_pm.c:	copy.source_handle = toxms? 0 : gvar->pm.xmm.XMSHandle;
src/lib/16_pm.c:	copy.target_handle = toxms? gvar->pm.xmm.XMSHandle : 0;
src/lib/16_pm.c:	word XMSHandle = gvar->pm.xmm.XMSHandle;
src/lib/16_pm.c:	if (gvar->pm.xmm.XMSPresent)
src/lib/16_pm.c:	if(gvar->pm.mm.MainPresent)
src/lib/16_pm.c:		printf("PM_SetMainMemPurge()	info of gvar->pm.mm.MainMemPages[i]\n");
src/lib/16_pm.c:		printf("&	%Fp,	%Fp\n", &gvar->pm.mm.MainMemPages[i],	&(gvar->pm.mm.MainMemPages[i]));
src/lib/16_pm.c:		if (gvar->pm.mm.MainMemPages[i])
src/lib/16_pm.c:			MM_SetPurge(&(gvar->pm.mm.MainMemPages[i]),level, gvar);
src/lib/16_pm.c:	if (!gvar->pm.mm.MainPresent)
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:			if (!gvar->pm.mm.MainMemPages[n])			// Yep, was the block purged?
src/lib/16_pm.c:	for (i = 0,p = gvar->pm.mm.MainMemPages,used = gvar->pm.mm.MainMemUsed; i < PMMaxMainMem;i++,p++,used++)
src/lib/16_pm.c:				gvar->pm.mm.MainPagesAvail--;			// and decrease available count
src/lib/16_pm.c:				gvar->pm.MainPagesUsed--;			// and decrease used count
src/lib/16_pm.c:				if (gvar->mm.mmerror)					// If it failed,
src/lib/16_pm.c:					gvar->pm.mm.MainPagesAvail++;			// and increase available count
src/lib/16_pm.c:	if (gvar->mm.mmerror)
src/lib/16_pm.c:		gvar->mm.mmerror = false;
src/lib/16_pm.c:	gvar->pm.mm.MainPagesAvail = 0;
src/lib/16_pm.c:	gvar->pm.mm.MainPresent = false;
src/lib/16_pm.c:	for (i = 0,p = gvar->pm.mm.MainMemPages;i < PMMaxMainMem;i++,p++)
src/lib/16_pm.c:		if (gvar->mm.mmerror)
src/lib/16_pm.c:		gvar->pm.mm.MainPagesAvail++;
src/lib/16_pm.c:		gvar->pm.mm.MainMemUsed[i] = pmba_Allocated;
src/lib/16_pm.c:	if (gvar->mm.mmerror)
src/lib/16_pm.c:		gvar->mm.mmerror = false;
src/lib/16_pm.c:	if (gvar->pm.mm.MainPagesAvail < PMMinMainMem)
src/lib/16_pm.c:	gvar->pm.mm.MainPresent = true;
src/lib/16_pm.c:	for (i = 0,p = gvar->pm.mm.MainMemPages;i < PMMaxMainMem;i++,p++)
src/lib/16_pm.c:	if (lseek(gvar->pm.fi.PageFile,offset,SEEK_SET) != offset)
src/lib/16_pm.c:	if (!CA_FarRead(gvar->pm.fi.PageFile,buf,length, gvar))
src/lib/16_pm.c:	gvar->pm.fi.PageFile = open(gvar->pm.fi.PageFileName,O_RDONLY + O_BINARY);
src/lib/16_pm.c:	if (gvar->pm.fi.PageFile == -1)
src/lib/16_pm.c:	read(gvar->pm.fi.PageFile,&gvar->pm.fi.ChunksInFile,sizeof(gvar->pm.fi.ChunksInFile));
src/lib/16_pm.c:	read(gvar->pm.fi.PageFile,&gvar->pm.fi.PMSpriteStart,sizeof(gvar->pm.fi.PMSpriteStart));
src/lib/16_pm.c:	read(gvar->pm.fi.PageFile,&gvar->pm.fi.PMSoundStart,sizeof(gvar->pm.fi.PMSoundStart));
src/lib/16_pm.c:	gvar->pm.PMNumBlocks = gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:	MM_GetPtr((memptr *)&gvar->pm.PMSegPages, sizeof(PageListStruct) * (gvar->pm.PMNumBlocks), gvar);
src/lib/16_pm.c:	MM_SetLock((memptr *)&gvar->pm.PMSegPages,true, gvar);
src/lib/16_pm.c:	gvar->pm.PMPages = (PageListStruct far *)gvar->pm.PMSegPages;
src/lib/16_pm.c:	_fmemset(gvar->pm.PMPages,0,sizeof(PageListStruct) * gvar->pm.PMNumBlocks);
src/lib/16_pm.c:	size = sizeof(dword) * gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:	if (!CA_FarRead(gvar->pm.fi.PageFile,(byte far *)buf,size, gvar))
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:	size = sizeof(word) * gvar->pm.fi.ChunksInFile;
src/lib/16_pm.c:	if (!CA_FarRead(gvar->pm.fi.PageFile,(byte far *)buf,size, gvar))
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:	if (gvar->pm.fi.PageFile != -1)
src/lib/16_pm.c:		close(gvar->pm.fi.PageFile);
src/lib/16_pm.c:	if (gvar->pm.PMSegPages)
src/lib/16_pm.c:		MM_SetLock((memptr *)&gvar->pm.PMSegPages,false, gvar);
src/lib/16_pm.c:		MM_FreePtr((void _seg *)&gvar->pm.PMSegPages, gvar);
src/lib/16_pm.c:		if (gvar->pm.emm.EMSList[i].baseEMSPage == emsbase)
src/lib/16_pm.c:			if (gvar->pm.emm.EMSList[i].lastHit < last)
src/lib/16_pm.c:				last = gvar->pm.emm.EMSList[i].lastHit;
src/lib/16_pm.c:		gvar->pm.emm.EMSList[emspage].baseEMSPage = emsbase;
src/lib/16_pm.c:	gvar->pm.emm.EMSList[emspage].lastHit = gvar->pm.PMFrameCount;
src/lib/16_pm.c:	return((memptr)(gvar->pm.emm.EMSPageFrame + offset));
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:		return(gvar->pm.mm.MainMemPages[page->mainPage]);
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages,lru = -1,last = LONG_MAX;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages,lru = -1,last = LONG_MAX;i < gvar->pm.fi.ChunksInFile;i++,page++)
src/lib/16_pm.c:		&&	(i != gvar->pm.xmm.XMSProtectPage)
src/lib/16_pm.c:	if (!gvar->pm.xmm.XMSPresent)
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if (gvar->pm.XMSPagesUsed < gvar->pm.xmm.XMSPagesAvail)
src/lib/16_pm.c:		page->xmsPage = gvar->pm.XMSPagesUsed++;
src/lib/16_pm.c:		page->xmsPage = gvar->pm.PMPages[usexms].xmsPage;
src/lib/16_pm.c:		gvar->pm.PMPages[usexms].xmsPage = -1;
src/lib/16_pm.c:	origpage = &gvar->pm.PMPages[orig];
src/lib/16_pm.c:	newpage = &gvar->pm.PMPages[new];
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if ((gvar->pm.EMSPagesUsed < gvar->pm.emm.EMSPagesAvail) && !mainonly)
src/lib/16_pm.c:		page->emsPage = gvar->pm.EMSPagesUsed++;
src/lib/16_pm.c:	else if (gvar->pm.MainPagesUsed < gvar->pm.mm.MainPagesAvail)
src/lib/16_pm.c:		for (i = 0,n = -1,used = gvar->pm.mm.MainMemUsed;i < PMMaxMainMem;i++,used++)
src/lib/16_pm.c:		addr = gvar->pm.mm.MainMemPages[n];
src/lib/16_pm.c:		gvar->pm.MainPagesUsed++;
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if (gvar->pm.xmm.XMSPresent && (page->xmsPage != -1))
src/lib/16_pm.c:		gvar->pm.xmm.XMSProtectPage = pagenum;
src/lib/16_pm.c:		gvar->pm.xmm.XMSProtectPage = -1;
src/lib/16_pm.c:	page = &gvar->pm.PMPages[pagenum];
src/lib/16_pm.c:	if (pagenum >= gvar->pm.fi.ChunksInFile)
src/lib/16_pm.c:		boolean mainonly = (pagenum >= gvar->pm.fi.PMSoundStart);
src/lib/16_pm.c:if (!gvar->pm.PMPages[pagenum].offset)	// JDC: sparse page
src/lib/16_pm.c:			if (gvar->pm.PMPages[pagenum].lastHit ==  gvar->pm.PMFrameCount)
src/lib/16_pm.c:				gvar->pm.PMThrashing++;
src/lib/16_pm.c:	gvar->pm.PMPages[pagenum].lastHit =  gvar->pm.PMFrameCount;
src/lib/16_pm.c:	if (pagenum < gvar->pm.fi.PMSoundStart)
src/lib/16_pm.c:	gvar->pm.PMPages[pagenum].locked = lock;
src/lib/16_pm.c:	mainfree = (gvar->pm.mm.MainPagesAvail - gvar->pm.MainPagesUsed) + (gvar->pm.emm.EMSPagesAvail - gvar->pm.EMSPagesUsed);
src/lib/16_pm.c:	xmsfree = (gvar->pm.xmm.XMSPagesAvail - gvar->pm.XMSPagesUsed);
src/lib/16_pm.c:	for (i = 0;i < gvar->pm.fi.ChunksInFile;i++)
src/lib/16_pm.c:		if (!gvar->pm.PMPages[i].offset)
src/lib/16_pm.c:		if ( gvar->pm.PMPages[i].emsPage != -1 || gvar->pm.PMPages[i].mainPage != -1 )
src/lib/16_pm.c:		else if ( xmsfree && (gvar->pm.PMPages[i].xmsPage == -1) )
src/lib/16_pm.c:		while ( !gvar->pm.PMPages[page].offset || gvar->pm.PMPages[page].mainPage != -1
src/lib/16_pm.c:			||	gvar->pm.PMPages[page].emsPage != -1 )
src/lib/16_pm.c:		if (page >= gvar->pm.fi.ChunksInFile)
src/lib/16_pm.c:			Quit (gvar, "PM_Preload: Pages>=gvar->pm.fi.ChunksInFile");
src/lib/16_pm.c:		for (oogypage = 0 ; gvar->pm.PMPages[oogypage].mainPage == -1 ; oogypage++)
src/lib/16_pm.c:			while ( !gvar->pm.PMPages[page].offset || gvar->pm.PMPages[page].xmsPage != -1 )
src/lib/16_pm.c:			if (page >= gvar->pm.fi.ChunksInFile)
src/lib/16_pm.c:				Quit (gvar, "PM_Preload: Pages>=gvar->pm.fi.ChunksInFile");
src/lib/16_pm.c:			p = &gvar->pm.PMPages[page];
src/lib/16_pm.c:			p->xmsPage = gvar->pm.XMSPagesUsed++;
src/lib/16_pm.c:			if (gvar->pm.XMSPagesUsed > gvar->pm.xmm.XMSPagesAvail)
src/lib/16_pm.c:		p = &gvar->pm.PMPages[oogypage];
src/lib/16_pm.c:	if (++gvar->pm.PMFrameCount >= LONG_MAX - 4)
src/lib/16_pm.c:		for (i = 0;i < gvar->pm.PMNumBlocks;i++)
src/lib/16_pm.c:			gvar->pm.PMPages[i].lastHit = 0;
src/lib/16_pm.c:		gvar->pm.PMFrameCount = 0;
src/lib/16_pm.c:	for (i = 0;i < gvar->pm.fi.PMSoundStart;i++)
src/lib/16_pm.c:		if (gvar->pm.PMPages[i].locked)
src/lib/16_pm.c:	if (gvar->pm.PMPanicMode)
src/lib/16_pm.c:		if ((!gvar->pm.PMThrashing) && (!--gvar->pm.PMPanicMode))
src/lib/16_pm.c:	if (gvar->pm.PMThrashing >= PMThrashThreshold)
src/lib/16_pm.c:		gvar->pm.PMPanicMode = PMUnThrashThreshold;
src/lib/16_pm.c:	gvar->pm.PMThrashing = false;
src/lib/16_pm.c:	gvar->pm.xmm.XMSPagesAvail = gvar->pm.xmm.XMSAvail / PMPageSizeKB;
src/lib/16_pm.c:	gvar->pm.emm.EMSPagesAvail = gvar->pm.emm.EMSAvail * (EMSPageSizeKB / PMPageSizeKB);
src/lib/16_pm.c:	gvar->pm.emm.EMSPhysicalPage = 0;
src/lib/16_pm.c:	gvar->pm.MainPagesUsed = gvar->pm.EMSPagesUsed = gvar->pm.XMSPagesUsed = 0;
src/lib/16_pm.c:	gvar->pm.PMPanicMode = false;
src/lib/16_pm.c:	gvar->pm.fi.PageFile = -1;
src/lib/16_pm.c:	gvar->pm.xmm.XMSProtectPage = -1;
src/lib/16_pm.c:	for (i = 0,page = gvar->pm.PMPages;i < gvar->pm.PMNumBlocks;i++,page++)
src/lib/16_pm.c:	if (gvar->pm.PMStarted)
src/lib/16_pm.c:	//0000+=+=strcpy(&(gvar->pm.fi.PageFileName), "VSWAP.");
src/lib/16_pm.c:	if (!gvar->pm.mm.MainPresent && !gvar->pm.emm.EMSPresent && !gvar->pm.xmm.XMSPresent)
src/lib/16_pm.c:	gvar->pm.PMStarted = true;
src/lib/16_pm.c:	if (!gvar->pm.PMStarted)
src/lib/16_sd.c:	gvar->ca.sd.irq0_ticks=
src/lib/16_sd.c:	//gvar->ca.sd.irq0_cnt=
src/lib/16_sd.c:	//gvar->ca.sd.irq0_add=
src/lib/16_sd.c:	gvar->ca.sd.imf_delay_countdown=
src/lib/16_sd.c:	gvar->ca.sd.irq0_max=0;
src/lib/16_sd.c:	gvar->ca.sd.imf_music=
src/lib/16_sd.c:	gvar->ca.sd.imf_play_ptr=
src/lib/16_sd.c:	gvar->ca.sd.imf_music_end=NULL;
src/lib/16_sd.c:	gvar->ca.sd.irq0_cnt = 0;
src/lib/16_sd.c:	gvar->ca.sd.irq0_add = 182;
src/lib/16_sd.c:	gvar->ca.sd.irq0_max = 1000; /* about 18.2Hz */
src/lib/16_sd.c:	if (gvar->ca.sd.imf_music) free(gvar->ca.sd.imf_music);
src/lib/16_sd.c:	MM_FreePtr(MEMPTR gvar->ca.audiosegs[0], gvar);	//TODO make behave like id engine
src/lib/16_sd.c:	gvar->ca.sd.imf_music = gvar->ca.sd.imf_play_ptr = gvar->ca.sd.imf_music_end = NULL;
src/lib/16_sd.c:	gvar->ca.sd.imf_delay_countdown = 0;
src/lib/16_sd.c:	MM_GetPtr(MEMPTR gvar->ca.audiosegs[0],len, gvar);
src/lib/16_sd.c:	gvar->ca.sd.imf_music = (struct imf_entry *)gvar->ca.audiosegs[0];
src/lib/16_sd.c:	if (gvar->ca.sd.imf_music == NULL) {
src/lib/16_sd.c:	read(fd,gvar->ca.sd.imf_music,len);
src/lib/16_sd.c:	gvar->ca.sd.imf_play_ptr = gvar->ca.sd.imf_music;
src/lib/16_sd.c:	gvar->ca.sd.imf_music_end = gvar->ca.sd.imf_music + (len >> 2UL);
src/lib/16_sd.c:	if (gvar->ca.sd.imf_delay_countdown == 0) {
src/lib/16_sd.c:			adlib_write(gvar->ca.sd.imf_play_ptr->reg,gvar->ca.sd.imf_play_ptr->data);
src/lib/16_sd.c:			gvar->ca.sd.imf_delay_countdown = gvar->ca.sd.imf_play_ptr->delay;
src/lib/16_sd.c:			gvar->ca.sd.imf_play_ptr++;
src/lib/16_sd.c:			if (gvar->ca.sd.imf_play_ptr == gvar->ca.sd.imf_music_end)
src/lib/16_sd.c:				gvar->ca.sd.imf_play_ptr = gvar->ca.sd.imf_music;
src/lib/16_sd.c:		} while (gvar->ca.sd.imf_delay_countdown == 0);
src/lib/16_sd.c:		gvar->ca.sd.imf_delay_countdown--;
src/lib/16_tail.c:	gvar->video.VL_Started=0;
src/lib/16_tail.c:	gvar->mm.mmstarted=0;
src/lib/16_tail.c:	gvar->pm.PMStarted=0;
src/lib/16_tail.c:	if(gvar->video.VL_Started)
src/lib/16_tail.c:	if(!gvar->video.old_mode) gvar->video.old_mode = vgaGetMode();//out.h.al;
src/lib/16_tail.c:	gvar->video.old_mode = 3;
src/lib/16_tail.c:	gvar->video.VL_Initiated = 1;
src/lib/16_tail.c:	printf("Total:	"); if(q) printf("	"); printf("%uk", gvar->mmi.mainmem/1024);
src/lib/16_us.c:	VLB_Bar(px,py,42,6,3/*BackColor*/, &gvar->video.ofs);
src/lib/16_us.c:	modexprint(gvar->video.page, px, py, 1, 0, 4, 8, 1, "YOU:");
src/lib/16_us.c:	VLB_Bar(px,py,50,6,3/*BackColor*/, &gvar->video.ofs);
src/lib/16_us.c:	modexprint(gvar->video.page, px, py, 1, 0, 4, 8, 1, "COMP:");
src/lib/16_us.c:				3/*BackColor*/, &gvar->video.ofs);
src/lib/16_us.c:		modexputPixel(gvar->video.page, BallMinX, BallMinY, 3);
src/lib/16_us.c:		modexputPixel(gvar->video.page, cx, CPaddleY, 3);
src/lib/16_us.c:		modexputPixel(gvar->video.page, kx, KPaddleY, 3);
src/lib/16_us.c:	} while ((gvar->in.inst->LastScan != sc_Escape) && !done);
src/lib/16_vrs.c:			CA_ReadFile(filename, &gvar->ca.spribuff, gvar);
src/lib/16_vrs.c:			CA_LoadFile(filename, &gvar->ca.spribuff, gvar);
src/lib/16_vrs.c:	enti->spri.spritesheet.buffer = gvar->ca.spribuff;
src/lib/16_mm.h:#define GETNEWBLOCK {if(!gvar->mm.mmfree)MML_ClearBlock(gvar);gvar->mm.mmnew=gvar->mm.mmfree;gvar->mm.mmfree=gvar->mm.mmfree->next;}
src/lib/16_mm.h:#define FREEBLOCK(x) {*x->useptr=NULL;x->next=gvar->mm.mmfree;gvar->mm.mmfree=x;}
src/lib/16_mm.h:#define MAPPAGES		4//gvar->mm.EMSpagesmapped
src/lib/vgmsnd/vgmSnd.c:	MM_GetPtr(MEMPTR gvar->ca.audiosegs[0], vgmFile->dataLen, gvar);
src/lib/vgmsnd/vgmSnd.c:	vgmFile->data = (UINT8*)gvar->ca.audiosegs[0];
src/lib/vgmsnd/vgmSnd.c:	MM_FreePtr(MEMPTR gvar->ca.audiosegs[0], gvar);
===============		./q.sh end		===============
